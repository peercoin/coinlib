// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Raw generated bindings to secp256k1
class NativeSecp256k1 {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeSecp256k1(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeSecp256k1.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// A built-in constant secp256k1 context object with static storage duration, to be
  /// used in conjunction with secp256k1_selftest.
  ///
  /// This context object offers *only limited functionality* , i.e., it cannot be used
  /// for API functions that perform computations involving secret keys, e.g., signing
  /// and public key generation. If this restriction applies to a specific API function,
  /// it is mentioned in its documentation. See secp256k1_context_create if you need a
  /// full context object that supports all functionality offered by the library.
  ///
  /// It is highly recommended to call secp256k1_selftest before using this context.
  late final ffi.Pointer<ffi.Pointer<secp256k1_context>>
      _secp256k1_context_static =
      _lookup<ffi.Pointer<secp256k1_context>>('secp256k1_context_static');

  ffi.Pointer<secp256k1_context> get secp256k1_context_static =>
      _secp256k1_context_static.value;

  set secp256k1_context_static(ffi.Pointer<secp256k1_context> value) =>
      _secp256k1_context_static.value = value;

  /// Deprecated alias for secp256k1_context_static.
  late final ffi.Pointer<ffi.Pointer<secp256k1_context>>
      _secp256k1_context_no_precomp =
      _lookup<ffi.Pointer<secp256k1_context>>('secp256k1_context_no_precomp');

  ffi.Pointer<secp256k1_context> get secp256k1_context_no_precomp =>
      _secp256k1_context_no_precomp.value;

  set secp256k1_context_no_precomp(ffi.Pointer<secp256k1_context> value) =>
      _secp256k1_context_no_precomp.value = value;

  /// Perform basic self tests (to be used in conjunction with secp256k1_context_static)
  ///
  /// This function performs self tests that detect some serious usage errors and
  /// similar conditions, e.g., when the library is compiled for the wrong endianness.
  /// This is a last resort measure to be used in production. The performed tests are
  /// very rudimentary and are not intended as a replacement for running the test
  /// binaries.
  ///
  /// It is highly recommended to call this before using secp256k1_context_static.
  /// It is not necessary to call this function before using a context created with
  /// secp256k1_context_create (or secp256k1_context_preallocated_create), which will
  /// take care of performing the self tests.
  ///
  /// If the tests fail, this function will call the default error handler to abort the
  /// program (see secp256k1_context_set_error_callback).
  void secp256k1_selftest() {
    return _secp256k1_selftest();
  }

  late final _secp256k1_selftestPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('secp256k1_selftest');
  late final _secp256k1_selftest =
      _secp256k1_selftestPtr.asFunction<void Function()>();

  /// Create a secp256k1 context object (in dynamically allocated memory).
  ///
  /// This function uses malloc to allocate memory. It is guaranteed that malloc is
  /// called at most once for every call of this function. If you need to avoid dynamic
  /// memory allocation entirely, see secp256k1_context_static and the functions in
  /// secp256k1_preallocated.h.
  ///
  /// Returns: pointer to a newly created context object.
  /// In:      flags: Always set to SECP256K1_CONTEXT_NONE (see below).
  ///
  /// The only valid non-deprecated flag in recent library versions is
  /// SECP256K1_CONTEXT_NONE, which will create a context sufficient for all functionality
  /// offered by the library. All other (deprecated) flags will be treated as equivalent
  /// to the SECP256K1_CONTEXT_NONE flag. Though the flags parameter primarily exists for
  /// historical reasons, future versions of the library may introduce new flags.
  ///
  /// If the context is intended to be used for API functions that perform computations
  /// involving secret keys, e.g., signing and public key generation, then it is highly
  /// recommended to call secp256k1_context_randomize on the context before calling
  /// those API functions. This will provide enhanced protection against side-channel
  /// leakage, see secp256k1_context_randomize for details.
  ///
  /// Do not create a new context object for each operation, as construction and
  /// randomization can take non-negligible time.
  ffi.Pointer<secp256k1_context> secp256k1_context_create(
    int flags,
  ) {
    return _secp256k1_context_create(
      flags,
    );
  }

  late final _secp256k1_context_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<secp256k1_context> Function(
              ffi.UnsignedInt)>>('secp256k1_context_create');
  late final _secp256k1_context_create = _secp256k1_context_createPtr
      .asFunction<ffi.Pointer<secp256k1_context> Function(int)>();

  /// Copy a secp256k1 context object (into dynamically allocated memory).
  ///
  /// This function uses malloc to allocate memory. It is guaranteed that malloc is
  /// called at most once for every call of this function. If you need to avoid dynamic
  /// memory allocation entirely, see the functions in secp256k1_preallocated.h.
  ///
  /// Cloning secp256k1_context_static is not possible, and should not be emulated by
  /// the caller (e.g., using memcpy). Create a new context instead.
  ///
  /// Returns: pointer to a newly created context object.
  /// Args:    ctx: pointer to a context to copy (not secp256k1_context_static).
  ffi.Pointer<secp256k1_context> secp256k1_context_clone(
    ffi.Pointer<secp256k1_context> ctx,
  ) {
    return _secp256k1_context_clone(
      ctx,
    );
  }

  late final _secp256k1_context_clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<secp256k1_context> Function(
              ffi.Pointer<secp256k1_context>)>>('secp256k1_context_clone');
  late final _secp256k1_context_clone = _secp256k1_context_clonePtr.asFunction<
      ffi.Pointer<secp256k1_context> Function(
          ffi.Pointer<secp256k1_context>)>();

  /// Destroy a secp256k1 context object (created in dynamically allocated memory).
  ///
  /// The context pointer may not be used afterwards.
  ///
  /// The context to destroy must have been created using secp256k1_context_create
  /// or secp256k1_context_clone. If the context has instead been created using
  /// secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone, the
  /// behaviour is undefined. In that case, secp256k1_context_preallocated_destroy must
  /// be used instead.
  ///
  /// Args:   ctx: pointer to a context to destroy, constructed using
  /// secp256k1_context_create or secp256k1_context_clone
  /// (i.e., not secp256k1_context_static).
  void secp256k1_context_destroy(
    ffi.Pointer<secp256k1_context> ctx,
  ) {
    return _secp256k1_context_destroy(
      ctx,
    );
  }

  late final _secp256k1_context_destroyPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<secp256k1_context>)>>(
      'secp256k1_context_destroy');
  late final _secp256k1_context_destroy = _secp256k1_context_destroyPtr
      .asFunction<void Function(ffi.Pointer<secp256k1_context>)>();

  /// Set a callback function to be called when an illegal argument is passed to
  /// an API call. It will only trigger for violations that are mentioned
  /// explicitly in the header.
  ///
  /// The philosophy is that these shouldn't be dealt with through a
  /// specific return value, as calling code should not have branches to deal with
  /// the case that this code itself is broken.
  ///
  /// On the other hand, during debug stage, one would want to be informed about
  /// such mistakes, and the default (crashing) may be inadvisable.
  /// When this callback is triggered, the API function called is guaranteed not
  /// to cause a crash, though its return value and output arguments are
  /// undefined.
  ///
  /// When this function has not been called (or called with fn==NULL), then the
  /// default handler will be used. The library provides a default handler which
  /// writes the message to stderr and calls abort. This default handler can be
  /// replaced at link time if the preprocessor macro
  /// USE_EXTERNAL_DEFAULT_CALLBACKS is defined, which is the case if the build
  /// has been configured with --enable-external-default-callbacks. Then the
  /// following two symbols must be provided to link against:
  /// - void secp256k1_default_illegal_callback_fn(const char *message, void *data);
  /// - void secp256k1_default_error_callback_fn(const char *message, void *data);
  /// The library can call these default handlers even before a proper callback data
  /// pointer could have been set using secp256k1_context_set_illegal_callback or
  /// secp256k1_context_set_error_callback, e.g., when the creation of a context
  /// fails. In this case, the corresponding default handler will be called with
  /// the data pointer argument set to NULL.
  ///
  /// Args: ctx:  pointer to a context object.
  /// In:   fun:  pointer to a function to call when an illegal argument is
  /// passed to the API, taking a message and an opaque pointer.
  /// (NULL restores the default handler.)
  /// data: the opaque pointer to pass to fun above, must be NULL for the default handler.
  ///
  /// See also secp256k1_context_set_error_callback.
  void secp256k1_context_set_illegal_callback(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Char> message, ffi.Pointer<ffi.Void> data)>>
        fun,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _secp256k1_context_set_illegal_callback(
      ctx,
      fun,
      data,
    );
  }

  late final _secp256k1_context_set_illegal_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Char> message,
                              ffi.Pointer<ffi.Void> data)>>,
                  ffi.Pointer<ffi.Void>)>>(
      'secp256k1_context_set_illegal_callback');
  late final _secp256k1_context_set_illegal_callback =
      _secp256k1_context_set_illegal_callbackPtr.asFunction<
          void Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Char> message,
                          ffi.Pointer<ffi.Void> data)>>,
              ffi.Pointer<ffi.Void>)>();

  /// Set a callback function to be called when an internal consistency check
  /// fails.
  ///
  /// The default callback writes an error message to stderr and calls abort
  /// to abort the program.
  ///
  /// This can only trigger in case of a hardware failure, miscompilation,
  /// memory corruption, serious bug in the library, or other error would can
  /// otherwise result in undefined behaviour. It will not trigger due to mere
  /// incorrect usage of the API (see secp256k1_context_set_illegal_callback
  /// for that). After this callback returns, anything may happen, including
  /// crashing.
  ///
  /// Args: ctx:  pointer to a context object.
  /// In:   fun:  pointer to a function to call when an internal error occurs,
  /// taking a message and an opaque pointer (NULL restores the
  /// default handler, see secp256k1_context_set_illegal_callback
  /// for details).
  /// data: the opaque pointer to pass to fun above, must be NULL for the default handler.
  ///
  /// See also secp256k1_context_set_illegal_callback.
  void secp256k1_context_set_error_callback(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Char> message, ffi.Pointer<ffi.Void> data)>>
        fun,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _secp256k1_context_set_error_callback(
      ctx,
      fun,
      data,
    );
  }

  late final _secp256k1_context_set_error_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Char> message,
                          ffi.Pointer<ffi.Void> data)>>,
              ffi.Pointer<ffi.Void>)>>('secp256k1_context_set_error_callback');
  late final _secp256k1_context_set_error_callback =
      _secp256k1_context_set_error_callbackPtr.asFunction<
          void Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Char> message,
                          ffi.Pointer<ffi.Void> data)>>,
              ffi.Pointer<ffi.Void>)>();

  /// Create a secp256k1 scratch space object.
  ///
  /// Returns: a newly created scratch space.
  /// Args: ctx:  pointer to a context object.
  /// In:   size: amount of memory to be available as scratch space. Some extra
  /// (<100 bytes) will be allocated for extra accounting.
  ffi.Pointer<secp256k1_scratch_space> secp256k1_scratch_space_create(
    ffi.Pointer<secp256k1_context> ctx,
    int size,
  ) {
    return _secp256k1_scratch_space_create(
      ctx,
      size,
    );
  }

  late final _secp256k1_scratch_space_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<secp256k1_scratch_space> Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Size)>>('secp256k1_scratch_space_create');
  late final _secp256k1_scratch_space_create =
      _secp256k1_scratch_space_createPtr.asFunction<
          ffi.Pointer<secp256k1_scratch_space> Function(
              ffi.Pointer<secp256k1_context>, int)>();

  /// Destroy a secp256k1 scratch space.
  ///
  /// The pointer may not be used afterwards.
  /// Args:       ctx: pointer to a context object.
  /// scratch: space to destroy
  void secp256k1_scratch_space_destroy(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_scratch_space> scratch,
  ) {
    return _secp256k1_scratch_space_destroy(
      ctx,
      scratch,
    );
  }

  late final _secp256k1_scratch_space_destroyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_scratch_space>)>>(
      'secp256k1_scratch_space_destroy');
  late final _secp256k1_scratch_space_destroy =
      _secp256k1_scratch_space_destroyPtr.asFunction<
          void Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_scratch_space>)>();

  /// Parse a variable-length public key into the pubkey object.
  ///
  /// Returns: 1 if the public key was fully valid.
  /// 0 if the public key could not be parsed or is invalid.
  /// Args: ctx:      pointer to a context object.
  /// Out:  pubkey:   pointer to a pubkey object. If 1 is returned, it is set to a
  /// parsed version of input. If not, its value is undefined.
  /// In:   input:    pointer to a serialized public key
  /// inputlen: length of the array pointed to by input
  ///
  /// This function supports parsing compressed (33 bytes, header byte 0x02 or
  /// 0x03), uncompressed (65 bytes, header byte 0x04), or hybrid (65 bytes, header
  /// byte 0x06 or 0x07) format public keys.
  int secp256k1_ec_pubkey_parse(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<ffi.UnsignedChar> input,
    int inputlen,
  ) {
    return _secp256k1_ec_pubkey_parse(
      ctx,
      pubkey,
      input,
      inputlen,
    );
  }

  late final _secp256k1_ec_pubkey_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('secp256k1_ec_pubkey_parse');
  late final _secp256k1_ec_pubkey_parse =
      _secp256k1_ec_pubkey_parsePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>,
              int)>();

  /// Serialize a pubkey object into a serialized byte sequence.
  ///
  /// Returns: 1 always.
  /// Args:   ctx:        pointer to a context object.
  /// Out:    output:     pointer to a 65-byte (if compressed==0) or 33-byte (if
  /// compressed==1) byte array to place the serialized key
  /// in.
  /// In/Out: outputlen:  pointer to an integer which is initially set to the
  /// size of output, and is overwritten with the written
  /// size.
  /// In:     pubkey:     pointer to a secp256k1_pubkey containing an
  /// initialized public key.
  /// flags:      SECP256K1_EC_COMPRESSED if serialization should be in
  /// compressed format, otherwise SECP256K1_EC_UNCOMPRESSED.
  int secp256k1_ec_pubkey_serialize(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> output,
    ffi.Pointer<ffi.Size> outputlen,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    int flags,
  ) {
    return _secp256k1_ec_pubkey_serialize(
      ctx,
      output,
      outputlen,
      pubkey,
      flags,
    );
  }

  late final _secp256k1_ec_pubkey_serializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.UnsignedInt)>>('secp256k1_ec_pubkey_serialize');
  late final _secp256k1_ec_pubkey_serialize =
      _secp256k1_ec_pubkey_serializePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<secp256k1_pubkey>,
              int)>();

  /// Compare two public keys using lexicographic (of compressed serialization) order
  ///
  /// Returns: <0 if the first public key is less than the second
  /// >0 if the first public key is greater than the second
  /// 0 if the two public keys are equal
  /// Args: ctx:      pointer to a context object
  /// In:   pubkey1:  first public key to compare
  /// pubkey2:  second public key to compare
  int secp256k1_ec_pubkey_cmp(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey1,
    ffi.Pointer<secp256k1_pubkey> pubkey2,
  ) {
    return _secp256k1_ec_pubkey_cmp(
      ctx,
      pubkey1,
      pubkey2,
    );
  }

  late final _secp256k1_ec_pubkey_cmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<secp256k1_pubkey>)>>('secp256k1_ec_pubkey_cmp');
  late final _secp256k1_ec_pubkey_cmp = _secp256k1_ec_pubkey_cmpPtr.asFunction<
      int Function(ffi.Pointer<secp256k1_context>,
          ffi.Pointer<secp256k1_pubkey>, ffi.Pointer<secp256k1_pubkey>)>();

  /// Sort public keys using lexicographic (of compressed serialization) order
  ///
  /// Returns: 0 if the arguments are invalid. 1 otherwise.
  ///
  /// Args:     ctx: pointer to a context object
  /// In:   pubkeys: array of pointers to pubkeys to sort
  /// n_pubkeys: number of elements in the pubkeys array
  int secp256k1_ec_pubkey_sort(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.Pointer<secp256k1_pubkey>> pubkeys,
    int n_pubkeys,
  ) {
    return _secp256k1_ec_pubkey_sort(
      ctx,
      pubkeys,
      n_pubkeys,
    );
  }

  late final _secp256k1_ec_pubkey_sortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.Pointer<secp256k1_pubkey>>,
              ffi.Size)>>('secp256k1_ec_pubkey_sort');
  late final _secp256k1_ec_pubkey_sort =
      _secp256k1_ec_pubkey_sortPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.Pointer<secp256k1_pubkey>>, int)>();

  /// Parse an ECDSA signature in compact (64 bytes) format.
  ///
  /// Returns: 1 when the signature could be parsed, 0 otherwise.
  /// Args: ctx:      pointer to a context object
  /// Out:  sig:      pointer to a signature object
  /// In:   input64:  pointer to the 64-byte array to parse
  ///
  /// The signature must consist of a 32-byte big endian R value, followed by a
  /// 32-byte big endian S value. If R or S fall outside of [0..order-1], the
  /// encoding is invalid. R and S with value 0 are allowed in the encoding.
  ///
  /// After the call, sig will always be initialized. If parsing failed or R or
  /// S are zero, the resulting sig value is guaranteed to fail verification for
  /// any message and public key.
  int secp256k1_ecdsa_signature_parse_compact(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> input64,
  ) {
    return _secp256k1_ecdsa_signature_parse_compact(
      ctx,
      sig,
      input64,
    );
  }

  late final _secp256k1_ecdsa_signature_parse_compactPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_ecdsa_signature>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_ecdsa_signature_parse_compact');
  late final _secp256k1_ecdsa_signature_parse_compact =
      _secp256k1_ecdsa_signature_parse_compactPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Parse a DER ECDSA signature.
  ///
  /// Returns: 1 when the signature could be parsed, 0 otherwise.
  /// Args: ctx:      pointer to a context object
  /// Out:  sig:      pointer to a signature object
  /// In:   input:    pointer to the signature to be parsed
  /// inputlen: the length of the array pointed to be input
  ///
  /// This function will accept any valid DER encoded signature, even if the
  /// encoded numbers are out of range.
  ///
  /// After the call, sig will always be initialized. If parsing failed or the
  /// encoded numbers are out of range, signature verification with it is
  /// guaranteed to fail for every message and public key.
  int secp256k1_ecdsa_signature_parse_der(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> input,
    int inputlen,
  ) {
    return _secp256k1_ecdsa_signature_parse_der(
      ctx,
      sig,
      input,
      inputlen,
    );
  }

  late final _secp256k1_ecdsa_signature_parse_derPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('secp256k1_ecdsa_signature_parse_der');
  late final _secp256k1_ecdsa_signature_parse_der =
      _secp256k1_ecdsa_signature_parse_derPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              int)>();

  /// Serialize an ECDSA signature in DER format.
  ///
  /// Returns: 1 if enough space was available to serialize, 0 otherwise
  /// Args:   ctx:       pointer to a context object
  /// Out:    output:    pointer to an array to store the DER serialization
  /// In/Out: outputlen: pointer to a length integer. Initially, this integer
  /// should be set to the length of output. After the call
  /// it will be set to the length of the serialization (even
  /// if 0 was returned).
  /// In:     sig:       pointer to an initialized signature object
  int secp256k1_ecdsa_signature_serialize_der(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> output,
    ffi.Pointer<ffi.Size> outputlen,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
  ) {
    return _secp256k1_ecdsa_signature_serialize_der(
      ctx,
      output,
      outputlen,
      sig,
    );
  }

  late final _secp256k1_ecdsa_signature_serialize_derPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<ffi.Size>,
                  ffi.Pointer<secp256k1_ecdsa_signature>)>>(
      'secp256k1_ecdsa_signature_serialize_der');
  late final _secp256k1_ecdsa_signature_serialize_der =
      _secp256k1_ecdsa_signature_serialize_derPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<secp256k1_ecdsa_signature>)>();

  /// Serialize an ECDSA signature in compact (64 byte) format.
  ///
  /// Returns: 1
  /// Args:   ctx:       pointer to a context object
  /// Out:    output64:  pointer to a 64-byte array to store the compact serialization
  /// In:     sig:       pointer to an initialized signature object
  ///
  /// See secp256k1_ecdsa_signature_parse_compact for details about the encoding.
  int secp256k1_ecdsa_signature_serialize_compact(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> output64,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
  ) {
    return _secp256k1_ecdsa_signature_serialize_compact(
      ctx,
      output64,
      sig,
    );
  }

  late final _secp256k1_ecdsa_signature_serialize_compactPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<secp256k1_ecdsa_signature>)>>(
      'secp256k1_ecdsa_signature_serialize_compact');
  late final _secp256k1_ecdsa_signature_serialize_compact =
      _secp256k1_ecdsa_signature_serialize_compactPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_ecdsa_signature>)>();

  /// Verify an ECDSA signature.
  ///
  /// Returns: 1: correct signature
  /// 0: incorrect or unparseable signature
  /// Args:    ctx:       pointer to a context object
  /// In:      sig:       the signature being verified.
  /// msghash32: the 32-byte message hash being verified.
  /// The verifier must make sure to apply a cryptographic
  /// hash function to the message by itself and not accept an
  /// msghash32 value directly. Otherwise, it would be easy to
  /// create a "valid" signature without knowledge of the
  /// secret key. See also
  /// https://bitcoin.stackexchange.com/a/81116/35586 for more
  /// background on this topic.
  /// pubkey:    pointer to an initialized public key to verify with.
  ///
  /// To avoid accepting malleable signatures, only ECDSA signatures in lower-S
  /// form are accepted.
  ///
  /// If you need to accept ECDSA signatures from sources that do not obey this
  /// rule, apply secp256k1_ecdsa_signature_normalize to the signature prior to
  /// verification, but be aware that doing so results in malleable signatures.
  ///
  /// For details, see the comments for that function.
  int secp256k1_ecdsa_verify(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> msghash32,
    ffi.Pointer<secp256k1_pubkey> pubkey,
  ) {
    return _secp256k1_ecdsa_verify(
      ctx,
      sig,
      msghash32,
      pubkey,
    );
  }

  late final _secp256k1_ecdsa_verifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_pubkey>)>>('secp256k1_ecdsa_verify');
  late final _secp256k1_ecdsa_verify = _secp256k1_ecdsa_verifyPtr.asFunction<
      int Function(
          ffi.Pointer<secp256k1_context>,
          ffi.Pointer<secp256k1_ecdsa_signature>,
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<secp256k1_pubkey>)>();

  /// Convert a signature to a normalized lower-S form.
  ///
  /// Returns: 1 if sigin was not normalized, 0 if it already was.
  /// Args: ctx:    pointer to a context object
  /// Out:  sigout: pointer to a signature to fill with the normalized form,
  /// or copy if the input was already normalized. (can be NULL if
  /// you're only interested in whether the input was already
  /// normalized).
  /// In:   sigin:  pointer to a signature to check/normalize (can be identical to sigout)
  ///
  /// With ECDSA a third-party can forge a second distinct signature of the same
  /// message, given a single initial signature, but without knowing the key. This
  /// is done by negating the S value modulo the order of the curve, 'flipping'
  /// the sign of the random point R which is not included in the signature.
  ///
  /// Forgery of the same message isn't universally problematic, but in systems
  /// where message malleability or uniqueness of signatures is important this can
  /// cause issues. This forgery can be blocked by all verifiers forcing signers
  /// to use a normalized form.
  ///
  /// The lower-S form reduces the size of signatures slightly on average when
  /// variable length encodings (such as DER) are used and is cheap to verify,
  /// making it a good choice. Security of always using lower-S is assured because
  /// anyone can trivially modify a signature after the fact to enforce this
  /// property anyway.
  ///
  /// The lower S value is always between 0x1 and
  /// 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,
  /// inclusive.
  ///
  /// No other forms of ECDSA malleability are known and none seem likely, but
  /// there is no formal proof that ECDSA, even with this additional restriction,
  /// is free of other malleability. Commonly used serialization schemes will also
  /// accept various non-unique encodings, so care should be taken when this
  /// property is required for an application.
  ///
  /// The secp256k1_ecdsa_sign function will by default create signatures in the
  /// lower-S form, and secp256k1_ecdsa_verify will not accept others. In case
  /// signatures come from a system that cannot enforce this property,
  /// secp256k1_ecdsa_signature_normalize must be called before verification.
  int secp256k1_ecdsa_signature_normalize(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_signature> sigout,
    ffi.Pointer<secp256k1_ecdsa_signature> sigin,
  ) {
    return _secp256k1_ecdsa_signature_normalize(
      ctx,
      sigout,
      sigin,
    );
  }

  late final _secp256k1_ecdsa_signature_normalizePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_ecdsa_signature>,
                  ffi.Pointer<secp256k1_ecdsa_signature>)>>(
      'secp256k1_ecdsa_signature_normalize');
  late final _secp256k1_ecdsa_signature_normalize =
      _secp256k1_ecdsa_signature_normalizePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<secp256k1_ecdsa_signature>)>();

  /// An implementation of RFC6979 (using HMAC-SHA256) as nonce generation function.
  /// If a data pointer is passed, it is assumed to be a pointer to 32 bytes of
  /// extra entropy.
  late final ffi.Pointer<secp256k1_nonce_function>
      _secp256k1_nonce_function_rfc6979 =
      _lookup<secp256k1_nonce_function>('secp256k1_nonce_function_rfc6979');

  secp256k1_nonce_function get secp256k1_nonce_function_rfc6979 =>
      _secp256k1_nonce_function_rfc6979.value;

  /// A default safe nonce generation function (currently equal to secp256k1_nonce_function_rfc6979).
  late final ffi.Pointer<secp256k1_nonce_function>
      _secp256k1_nonce_function_default =
      _lookup<secp256k1_nonce_function>('secp256k1_nonce_function_default');

  secp256k1_nonce_function get secp256k1_nonce_function_default =>
      _secp256k1_nonce_function_default.value;

  /// Create an ECDSA signature.
  ///
  /// Returns: 1: signature created
  /// 0: the nonce generation function failed, or the secret key was invalid.
  /// Args:    ctx:       pointer to a context object (not secp256k1_context_static).
  /// Out:     sig:       pointer to an array where the signature will be placed.
  /// In:      msghash32: the 32-byte message hash being signed.
  /// seckey:    pointer to a 32-byte secret key.
  /// noncefp:   pointer to a nonce generation function. If NULL,
  /// secp256k1_nonce_function_default is used.
  /// ndata:     pointer to arbitrary data used by the nonce generation function
  /// (can be NULL). If it is non-NULL and
  /// secp256k1_nonce_function_default is used, then ndata must be a
  /// pointer to 32-bytes of additional data.
  ///
  /// The created signature is always in lower-S form. See
  /// secp256k1_ecdsa_signature_normalize for more details.
  int secp256k1_ecdsa_sign(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> msghash32,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    secp256k1_nonce_function noncefp,
    ffi.Pointer<ffi.Void> ndata,
  ) {
    return _secp256k1_ecdsa_sign(
      ctx,
      sig,
      msghash32,
      seckey,
      noncefp,
      ndata,
    );
  }

  late final _secp256k1_ecdsa_signPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              secp256k1_nonce_function,
              ffi.Pointer<ffi.Void>)>>('secp256k1_ecdsa_sign');
  late final _secp256k1_ecdsa_sign = _secp256k1_ecdsa_signPtr.asFunction<
      int Function(
          ffi.Pointer<secp256k1_context>,
          ffi.Pointer<secp256k1_ecdsa_signature>,
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<ffi.UnsignedChar>,
          secp256k1_nonce_function,
          ffi.Pointer<ffi.Void>)>();

  /// Verify an ECDSA secret key.
  ///
  /// A secret key is valid if it is not 0 and less than the secp256k1 curve order
  /// when interpreted as an integer (most significant byte first). The
  /// probability of choosing a 32-byte string uniformly at random which is an
  /// invalid secret key is negligible.
  ///
  /// Returns: 1: secret key is valid
  /// 0: secret key is invalid
  /// Args:    ctx: pointer to a context object.
  /// In:      seckey: pointer to a 32-byte secret key.
  int secp256k1_ec_seckey_verify(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seckey,
  ) {
    return _secp256k1_ec_seckey_verify(
      ctx,
      seckey,
    );
  }

  late final _secp256k1_ec_seckey_verifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_seckey_verify');
  late final _secp256k1_ec_seckey_verify =
      _secp256k1_ec_seckey_verifyPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Compute the public key for a secret key.
  ///
  /// Returns: 1: secret was valid, public key stores.
  /// 0: secret was invalid, try again.
  /// Args:    ctx:    pointer to a context object (not secp256k1_context_static).
  /// Out:     pubkey: pointer to the created public key.
  /// In:      seckey: pointer to a 32-byte secret key.
  int secp256k1_ec_pubkey_create(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<ffi.UnsignedChar> seckey,
  ) {
    return _secp256k1_ec_pubkey_create(
      ctx,
      pubkey,
      seckey,
    );
  }

  late final _secp256k1_ec_pubkey_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_pubkey_create');
  late final _secp256k1_ec_pubkey_create =
      _secp256k1_ec_pubkey_createPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Negates a secret key in place.
  ///
  /// Returns: 0 if the given secret key is invalid according to
  /// secp256k1_ec_seckey_verify. 1 otherwise
  /// Args:   ctx:    pointer to a context object
  /// In/Out: seckey: pointer to the 32-byte secret key to be negated. If the
  /// secret key is invalid according to
  /// secp256k1_ec_seckey_verify, this function returns 0 and
  /// seckey will be set to some unspecified value.
  int secp256k1_ec_seckey_negate(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seckey,
  ) {
    return _secp256k1_ec_seckey_negate(
      ctx,
      seckey,
    );
  }

  late final _secp256k1_ec_seckey_negatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_seckey_negate');
  late final _secp256k1_ec_seckey_negate =
      _secp256k1_ec_seckey_negatePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Same as secp256k1_ec_seckey_negate, but DEPRECATED. Will be removed in
  /// future versions.
  int secp256k1_ec_privkey_negate(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seckey,
  ) {
    return _secp256k1_ec_privkey_negate(
      ctx,
      seckey,
    );
  }

  late final _secp256k1_ec_privkey_negatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_privkey_negate');
  late final _secp256k1_ec_privkey_negate =
      _secp256k1_ec_privkey_negatePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Negates a public key in place.
  ///
  /// Returns: 1 always
  /// Args:   ctx:        pointer to a context object
  /// In/Out: pubkey:     pointer to the public key to be negated.
  int secp256k1_ec_pubkey_negate(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
  ) {
    return _secp256k1_ec_pubkey_negate(
      ctx,
      pubkey,
    );
  }

  late final _secp256k1_ec_pubkey_negatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>)>>('secp256k1_ec_pubkey_negate');
  late final _secp256k1_ec_pubkey_negate =
      _secp256k1_ec_pubkey_negatePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>, ffi.Pointer<secp256k1_pubkey>)>();

  /// Tweak a secret key by adding tweak to it.
  ///
  /// Returns: 0 if the arguments are invalid or the resulting secret key would be
  /// invalid (only when the tweak is the negation of the secret key). 1
  /// otherwise.
  /// Args:    ctx:   pointer to a context object.
  /// In/Out: seckey: pointer to a 32-byte secret key. If the secret key is
  /// invalid according to secp256k1_ec_seckey_verify, this
  /// function returns 0. seckey will be set to some unspecified
  /// value if this function returns 0.
  /// In:    tweak32: pointer to a 32-byte tweak, which must be valid according to
  /// secp256k1_ec_seckey_verify or 32 zero bytes. For uniformly
  /// random 32-byte tweaks, the chance of being invalid is
  /// negligible (around 1 in 2^128).
  int secp256k1_ec_seckey_tweak_add(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_ec_seckey_tweak_add(
      ctx,
      seckey,
      tweak32,
    );
  }

  late final _secp256k1_ec_seckey_tweak_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_seckey_tweak_add');
  late final _secp256k1_ec_seckey_tweak_add =
      _secp256k1_ec_seckey_tweak_addPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Same as secp256k1_ec_seckey_tweak_add, but DEPRECATED. Will be removed in
  /// future versions.
  int secp256k1_ec_privkey_tweak_add(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_ec_privkey_tweak_add(
      ctx,
      seckey,
      tweak32,
    );
  }

  late final _secp256k1_ec_privkey_tweak_addPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_ec_privkey_tweak_add');
  late final _secp256k1_ec_privkey_tweak_add =
      _secp256k1_ec_privkey_tweak_addPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Tweak a public key by adding tweak times the generator to it.
  ///
  /// Returns: 0 if the arguments are invalid or the resulting public key would be
  /// invalid (only when the tweak is the negation of the corresponding
  /// secret key). 1 otherwise.
  /// Args:    ctx:   pointer to a context object.
  /// In/Out: pubkey: pointer to a public key object. pubkey will be set to an
  /// invalid value if this function returns 0.
  /// In:    tweak32: pointer to a 32-byte tweak, which must be valid according to
  /// secp256k1_ec_seckey_verify or 32 zero bytes. For uniformly
  /// random 32-byte tweaks, the chance of being invalid is
  /// negligible (around 1 in 2^128).
  int secp256k1_ec_pubkey_tweak_add(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_ec_pubkey_tweak_add(
      ctx,
      pubkey,
      tweak32,
    );
  }

  late final _secp256k1_ec_pubkey_tweak_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_pubkey_tweak_add');
  late final _secp256k1_ec_pubkey_tweak_add =
      _secp256k1_ec_pubkey_tweak_addPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Tweak a secret key by multiplying it by a tweak.
  ///
  /// Returns: 0 if the arguments are invalid. 1 otherwise.
  /// Args:   ctx:    pointer to a context object.
  /// In/Out: seckey: pointer to a 32-byte secret key. If the secret key is
  /// invalid according to secp256k1_ec_seckey_verify, this
  /// function returns 0. seckey will be set to some unspecified
  /// value if this function returns 0.
  /// In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to
  /// secp256k1_ec_seckey_verify, this function returns 0. For
  /// uniformly random 32-byte arrays the chance of being invalid
  /// is negligible (around 1 in 2^128).
  int secp256k1_ec_seckey_tweak_mul(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_ec_seckey_tweak_mul(
      ctx,
      seckey,
      tweak32,
    );
  }

  late final _secp256k1_ec_seckey_tweak_mulPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_seckey_tweak_mul');
  late final _secp256k1_ec_seckey_tweak_mul =
      _secp256k1_ec_seckey_tweak_mulPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Same as secp256k1_ec_seckey_tweak_mul, but DEPRECATED. Will be removed in
  /// future versions.
  int secp256k1_ec_privkey_tweak_mul(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_ec_privkey_tweak_mul(
      ctx,
      seckey,
      tweak32,
    );
  }

  late final _secp256k1_ec_privkey_tweak_mulPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_ec_privkey_tweak_mul');
  late final _secp256k1_ec_privkey_tweak_mul =
      _secp256k1_ec_privkey_tweak_mulPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Tweak a public key by multiplying it by a tweak value.
  ///
  /// Returns: 0 if the arguments are invalid. 1 otherwise.
  /// Args:    ctx:   pointer to a context object.
  /// In/Out: pubkey: pointer to a public key object. pubkey will be set to an
  /// invalid value if this function returns 0.
  /// In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to
  /// secp256k1_ec_seckey_verify, this function returns 0. For
  /// uniformly random 32-byte arrays the chance of being invalid
  /// is negligible (around 1 in 2^128).
  int secp256k1_ec_pubkey_tweak_mul(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_ec_pubkey_tweak_mul(
      ctx,
      pubkey,
      tweak32,
    );
  }

  late final _secp256k1_ec_pubkey_tweak_mulPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_pubkey_tweak_mul');
  late final _secp256k1_ec_pubkey_tweak_mul =
      _secp256k1_ec_pubkey_tweak_mulPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Randomizes the context to provide enhanced protection against side-channel leakage.
  ///
  /// Returns: 1: randomization successful
  /// 0: error
  /// Args:    ctx:       pointer to a context object (not secp256k1_context_static).
  /// In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state).
  ///
  /// While secp256k1 code is written and tested to be constant-time no matter what
  /// secret values are, it is possible that a compiler may output code which is not,
  /// and also that the CPU may not emit the same radio frequencies or draw the same
  /// amount of power for all values. Randomization of the context shields against
  /// side-channel observations which aim to exploit secret-dependent behaviour in
  /// certain computations which involve secret keys.
  ///
  /// It is highly recommended to call this function on contexts returned from
  /// secp256k1_context_create or secp256k1_context_clone (or from the corresponding
  /// functions in secp256k1_preallocated.h) before using these contexts to call API
  /// functions that perform computations involving secret keys, e.g., signing and
  /// public key generation. It is possible to call this function more than once on
  /// the same context, and doing so before every few computations involving secret
  /// keys is recommended as a defense-in-depth measure. Randomization of the static
  /// context secp256k1_context_static is not supported.
  ///
  /// Currently, the random seed is mainly used for blinding multiplications of a
  /// secret scalar with the elliptic curve base point. Multiplications of this
  /// kind are performed by exactly those API functions which are documented to
  /// require a context that is not secp256k1_context_static. As a rule of thumb,
  /// these are all functions which take a secret key (or a keypair) as an input.
  /// A notable exception to that rule is the ECDH module, which relies on a different
  /// kind of elliptic curve point multiplication and thus does not benefit from
  /// enhanced protection against side-channel leakage currently.
  int secp256k1_context_randomize(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seed32,
  ) {
    return _secp256k1_context_randomize(
      ctx,
      seed32,
    );
  }

  late final _secp256k1_context_randomizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_context_randomize');
  late final _secp256k1_context_randomize =
      _secp256k1_context_randomizePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Add a number of public keys together.
  ///
  /// Returns: 1: the sum of the public keys is valid.
  /// 0: the sum of the public keys is not valid.
  /// Args:   ctx:        pointer to a context object.
  /// Out:    out:        pointer to a public key object for placing the resulting public key.
  /// In:     ins:        pointer to array of pointers to public keys.
  /// n:          the number of public keys to add together (must be at least 1).
  int secp256k1_ec_pubkey_combine(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> out,
    ffi.Pointer<ffi.Pointer<secp256k1_pubkey>> ins,
    int n,
  ) {
    return _secp256k1_ec_pubkey_combine(
      ctx,
      out,
      ins,
      n,
    );
  }

  late final _secp256k1_ec_pubkey_combinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.Pointer<secp256k1_pubkey>>,
              ffi.Size)>>('secp256k1_ec_pubkey_combine');
  late final _secp256k1_ec_pubkey_combine =
      _secp256k1_ec_pubkey_combinePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.Pointer<secp256k1_pubkey>>,
              int)>();

  /// Compute a tagged hash as defined in BIP-340.
  ///
  /// This is useful for creating a message hash and achieving domain separation
  /// through an application-specific tag. This function returns
  /// SHA256(SHA256(tag)||SHA256(tag)||msg). Therefore, tagged hash
  /// implementations optimized for a specific tag can precompute the SHA256 state
  /// after hashing the tag hashes.
  ///
  /// Returns: 1 always.
  /// Args:    ctx: pointer to a context object
  /// Out:  hash32: pointer to a 32-byte array to store the resulting hash
  /// In:      tag: pointer to an array containing the tag
  /// taglen: length of the tag array
  /// msg: pointer to an array containing the message
  /// msglen: length of the message array
  int secp256k1_tagged_sha256(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> hash32,
    ffi.Pointer<ffi.UnsignedChar> tag,
    int taglen,
    ffi.Pointer<ffi.UnsignedChar> msg,
    int msglen,
  ) {
    return _secp256k1_tagged_sha256(
      ctx,
      hash32,
      tag,
      taglen,
      msg,
      msglen,
    );
  }

  late final _secp256k1_tagged_sha256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('secp256k1_tagged_sha256');
  late final _secp256k1_tagged_sha256 = _secp256k1_tagged_sha256Ptr.asFunction<
      int Function(
          ffi.Pointer<secp256k1_context>,
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int)>();

  /// Parse a compact ECDSA signature (64 bytes + recovery id).
  ///
  /// Returns: 1 when the signature could be parsed, 0 otherwise
  /// Args: ctx:     pointer to a context object
  /// Out:  sig:     pointer to a signature object
  /// In:   input64: pointer to a 64-byte compact signature
  /// recid:   the recovery id (0, 1, 2 or 3)
  int secp256k1_ecdsa_recoverable_signature_parse_compact(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_recoverable_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> input64,
    int recid,
  ) {
    return _secp256k1_ecdsa_recoverable_signature_parse_compact(
      ctx,
      sig,
      input64,
      recid,
    );
  }

  late final _secp256k1_ecdsa_recoverable_signature_parse_compactPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int)>>('secp256k1_ecdsa_recoverable_signature_parse_compact');
  late final _secp256k1_ecdsa_recoverable_signature_parse_compact =
      _secp256k1_ecdsa_recoverable_signature_parse_compactPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              int)>();

  /// Convert a recoverable signature into a normal signature.
  ///
  /// Returns: 1
  /// Args: ctx:    pointer to a context object.
  /// Out:  sig:    pointer to a normal signature.
  /// In:   sigin:  pointer to a recoverable signature.
  int secp256k1_ecdsa_recoverable_signature_convert(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
    ffi.Pointer<secp256k1_ecdsa_recoverable_signature> sigin,
  ) {
    return _secp256k1_ecdsa_recoverable_signature_convert(
      ctx,
      sig,
      sigin,
    );
  }

  late final _secp256k1_ecdsa_recoverable_signature_convertPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_ecdsa_signature>,
                  ffi.Pointer<secp256k1_ecdsa_recoverable_signature>)>>(
      'secp256k1_ecdsa_recoverable_signature_convert');
  late final _secp256k1_ecdsa_recoverable_signature_convert =
      _secp256k1_ecdsa_recoverable_signature_convertPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>)>();

  /// Serialize an ECDSA signature in compact format (64 bytes + recovery id).
  ///
  /// Returns: 1
  /// Args: ctx:      pointer to a context object.
  /// Out:  output64: pointer to a 64-byte array of the compact signature.
  /// recid:    pointer to an integer to hold the recovery id.
  /// In:   sig:      pointer to an initialized signature object.
  int secp256k1_ecdsa_recoverable_signature_serialize_compact(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> output64,
    ffi.Pointer<ffi.Int> recid,
    ffi.Pointer<secp256k1_ecdsa_recoverable_signature> sig,
  ) {
    return _secp256k1_ecdsa_recoverable_signature_serialize_compact(
      ctx,
      output64,
      recid,
      sig,
    );
  }

  late final _secp256k1_ecdsa_recoverable_signature_serialize_compactPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<secp256k1_context>,
                      ffi.Pointer<ffi.UnsignedChar>,
                      ffi.Pointer<ffi.Int>,
                      ffi.Pointer<secp256k1_ecdsa_recoverable_signature>)>>(
          'secp256k1_ecdsa_recoverable_signature_serialize_compact');
  late final _secp256k1_ecdsa_recoverable_signature_serialize_compact =
      _secp256k1_ecdsa_recoverable_signature_serialize_compactPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>)>();

  /// Create a recoverable ECDSA signature.
  ///
  /// Returns: 1: signature created
  /// 0: the nonce generation function failed, or the secret key was invalid.
  /// Args:    ctx:       pointer to a context object (not secp256k1_context_static).
  /// Out:     sig:       pointer to an array where the signature will be placed.
  /// In:      msghash32: the 32-byte message hash being signed.
  /// seckey:    pointer to a 32-byte secret key.
  /// noncefp:   pointer to a nonce generation function. If NULL,
  /// secp256k1_nonce_function_default is used.
  /// ndata:     pointer to arbitrary data used by the nonce generation function
  /// (can be NULL for secp256k1_nonce_function_default).
  int secp256k1_ecdsa_sign_recoverable(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_recoverable_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> msghash32,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    secp256k1_nonce_function noncefp,
    ffi.Pointer<ffi.Void> ndata,
  ) {
    return _secp256k1_ecdsa_sign_recoverable(
      ctx,
      sig,
      msghash32,
      seckey,
      noncefp,
      ndata,
    );
  }

  late final _secp256k1_ecdsa_sign_recoverablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              secp256k1_nonce_function,
              ffi.Pointer<ffi.Void>)>>('secp256k1_ecdsa_sign_recoverable');
  late final _secp256k1_ecdsa_sign_recoverable =
      _secp256k1_ecdsa_sign_recoverablePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              secp256k1_nonce_function,
              ffi.Pointer<ffi.Void>)>();

  /// Recover an ECDSA public key from a signature.
  ///
  /// Returns: 1: public key successfully recovered (which guarantees a correct signature).
  /// 0: otherwise.
  /// Args:    ctx:       pointer to a context object.
  /// Out:     pubkey:    pointer to the recovered public key.
  /// In:      sig:       pointer to initialized signature that supports pubkey recovery.
  /// msghash32: the 32-byte message hash assumed to be signed.
  int secp256k1_ecdsa_recover(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<secp256k1_ecdsa_recoverable_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> msghash32,
  ) {
    return _secp256k1_ecdsa_recover(
      ctx,
      pubkey,
      sig,
      msghash32,
    );
  }

  late final _secp256k1_ecdsa_recoverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ecdsa_recover');
  late final _secp256k1_ecdsa_recover = _secp256k1_ecdsa_recoverPtr.asFunction<
      int Function(
          ffi.Pointer<secp256k1_context>,
          ffi.Pointer<secp256k1_pubkey>,
          ffi.Pointer<secp256k1_ecdsa_recoverable_signature>,
          ffi.Pointer<ffi.UnsignedChar>)>();

  /// Parse a 32-byte sequence into a xonly_pubkey object.
  ///
  /// Returns: 1 if the public key was fully valid.
  /// 0 if the public key could not be parsed or is invalid.
  ///
  /// Args:   ctx: pointer to a context object.
  /// Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a
  /// parsed version of input. If not, it's set to an invalid value.
  /// In: input32: pointer to a serialized xonly_pubkey.
  int secp256k1_xonly_pubkey_parse(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_xonly_pubkey> pubkey,
    ffi.Pointer<ffi.UnsignedChar> input32,
  ) {
    return _secp256k1_xonly_pubkey_parse(
      ctx,
      pubkey,
      input32,
    );
  }

  late final _secp256k1_xonly_pubkey_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_xonly_pubkey_parse');
  late final _secp256k1_xonly_pubkey_parse =
      _secp256k1_xonly_pubkey_parsePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Serialize an xonly_pubkey object into a 32-byte sequence.
  ///
  /// Returns: 1 always.
  ///
  /// Args:     ctx: pointer to a context object.
  /// Out: output32: pointer to a 32-byte array to place the serialized key in.
  /// In:    pubkey: pointer to a secp256k1_xonly_pubkey containing an initialized public key.
  int secp256k1_xonly_pubkey_serialize(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> output32,
    ffi.Pointer<secp256k1_xonly_pubkey> pubkey,
  ) {
    return _secp256k1_xonly_pubkey_serialize(
      ctx,
      output32,
      pubkey,
    );
  }

  late final _secp256k1_xonly_pubkey_serializePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<secp256k1_xonly_pubkey>)>>(
      'secp256k1_xonly_pubkey_serialize');
  late final _secp256k1_xonly_pubkey_serialize =
      _secp256k1_xonly_pubkey_serializePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_xonly_pubkey>)>();

  /// Compare two x-only public keys using lexicographic order
  ///
  /// Returns: <0 if the first public key is less than the second
  /// >0 if the first public key is greater than the second
  /// 0 if the two public keys are equal
  /// Args: ctx:      pointer to a context object.
  /// In:   pubkey1:  first public key to compare
  /// pubkey2:  second public key to compare
  int secp256k1_xonly_pubkey_cmp(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_xonly_pubkey> pk1,
    ffi.Pointer<secp256k1_xonly_pubkey> pk2,
  ) {
    return _secp256k1_xonly_pubkey_cmp(
      ctx,
      pk1,
      pk2,
    );
  }

  late final _secp256k1_xonly_pubkey_cmpPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_xonly_pubkey>,
                  ffi.Pointer<secp256k1_xonly_pubkey>)>>(
      'secp256k1_xonly_pubkey_cmp');
  late final _secp256k1_xonly_pubkey_cmp =
      _secp256k1_xonly_pubkey_cmpPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<secp256k1_xonly_pubkey>)>();

  /// Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.
  ///
  /// Returns: 1 always.
  ///
  /// Args:         ctx: pointer to a context object.
  /// Out: xonly_pubkey: pointer to an x-only public key object for placing the converted public key.
  /// pk_parity: Ignored if NULL. Otherwise, pointer to an integer that
  /// will be set to 1 if the point encoded by xonly_pubkey is
  /// the negation of the pubkey and set to 0 otherwise.
  /// In:        pubkey: pointer to a public key that is converted.
  int secp256k1_xonly_pubkey_from_pubkey(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_xonly_pubkey> xonly_pubkey,
    ffi.Pointer<ffi.Int> pk_parity,
    ffi.Pointer<secp256k1_pubkey> pubkey,
  ) {
    return _secp256k1_xonly_pubkey_from_pubkey(
      ctx,
      xonly_pubkey,
      pk_parity,
      pubkey,
    );
  }

  late final _secp256k1_xonly_pubkey_from_pubkeyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_xonly_pubkey>,
                  ffi.Pointer<ffi.Int>,
                  ffi.Pointer<secp256k1_pubkey>)>>(
      'secp256k1_xonly_pubkey_from_pubkey');
  late final _secp256k1_xonly_pubkey_from_pubkey =
      _secp256k1_xonly_pubkey_from_pubkeyPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<secp256k1_pubkey>)>();

  /// Tweak an x-only public key by adding the generator multiplied with tweak32
  /// to it.
  ///
  /// Note that the resulting point can not in general be represented by an x-only
  /// pubkey because it may have an odd Y coordinate. Instead, the output_pubkey
  /// is a normal secp256k1_pubkey.
  ///
  /// Returns: 0 if the arguments are invalid or the resulting public key would be
  /// invalid (only when the tweak is the negation of the corresponding
  /// secret key). 1 otherwise.
  ///
  /// Args:           ctx: pointer to a context object.
  /// Out:  output_pubkey: pointer to a public key to store the result. Will be set
  /// to an invalid value if this function returns 0.
  /// In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.
  /// tweak32: pointer to a 32-byte tweak, which must be valid
  /// according to secp256k1_ec_seckey_verify or 32 zero
  /// bytes. For uniformly random 32-byte tweaks, the chance of
  /// being invalid is negligible (around 1 in 2^128).
  int secp256k1_xonly_pubkey_tweak_add(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> output_pubkey,
    ffi.Pointer<secp256k1_xonly_pubkey> internal_pubkey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_xonly_pubkey_tweak_add(
      ctx,
      output_pubkey,
      internal_pubkey,
      tweak32,
    );
  }

  late final _secp256k1_xonly_pubkey_tweak_addPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_pubkey>,
                  ffi.Pointer<secp256k1_xonly_pubkey>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_xonly_pubkey_tweak_add');
  late final _secp256k1_xonly_pubkey_tweak_add =
      _secp256k1_xonly_pubkey_tweak_addPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Checks that a tweaked pubkey is the result of calling
  /// secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.
  ///
  /// The tweaked pubkey is represented by its 32-byte x-only serialization and
  /// its pk_parity, which can both be obtained by converting the result of
  /// tweak_add to a secp256k1_xonly_pubkey.
  ///
  /// Note that this alone does _not_ verify that the tweaked pubkey is a
  /// commitment. If the tweak is not chosen in a specific way, the tweaked pubkey
  /// can easily be the result of a different internal_pubkey and tweak.
  ///
  /// Returns: 0 if the arguments are invalid or the tweaked pubkey is not the
  /// result of tweaking the internal_pubkey with tweak32. 1 otherwise.
  /// Args:            ctx: pointer to a context object.
  /// In: tweaked_pubkey32: pointer to a serialized xonly_pubkey.
  /// tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization
  /// is passed in as tweaked_pubkey32). This must match the
  /// pk_parity value that is returned when calling
  /// secp256k1_xonly_pubkey with the tweaked pubkey, or
  /// this function will fail.
  /// internal_pubkey: pointer to an x-only public key object to apply the tweak to.
  /// tweak32: pointer to a 32-byte tweak.
  int secp256k1_xonly_pubkey_tweak_add_check(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> tweaked_pubkey32,
    int tweaked_pk_parity,
    ffi.Pointer<secp256k1_xonly_pubkey> internal_pubkey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_xonly_pubkey_tweak_add_check(
      ctx,
      tweaked_pubkey32,
      tweaked_pk_parity,
      internal_pubkey,
      tweak32,
    );
  }

  late final _secp256k1_xonly_pubkey_tweak_add_checkPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Int,
                  ffi.Pointer<secp256k1_xonly_pubkey>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_xonly_pubkey_tweak_add_check');
  late final _secp256k1_xonly_pubkey_tweak_add_check =
      _secp256k1_xonly_pubkey_tweak_add_checkPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Compute the keypair for a secret key.
  ///
  /// Returns: 1: secret was valid, keypair is ready to use
  /// 0: secret was invalid, try again with a different secret
  /// Args:    ctx: pointer to a context object (not secp256k1_context_static).
  /// Out: keypair: pointer to the created keypair.
  /// In:   seckey: pointer to a 32-byte secret key.
  int secp256k1_keypair_create(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_keypair> keypair,
    ffi.Pointer<ffi.UnsignedChar> seckey,
  ) {
    return _secp256k1_keypair_create(
      ctx,
      keypair,
      seckey,
    );
  }

  late final _secp256k1_keypair_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_keypair_create');
  late final _secp256k1_keypair_create =
      _secp256k1_keypair_createPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_keypair>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Get the secret key from a keypair.
  ///
  /// Returns: 1 always.
  /// Args:   ctx: pointer to a context object.
  /// Out: seckey: pointer to a 32-byte buffer for the secret key.
  /// In: keypair: pointer to a keypair.
  int secp256k1_keypair_sec(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    ffi.Pointer<secp256k1_keypair> keypair,
  ) {
    return _secp256k1_keypair_sec(
      ctx,
      seckey,
      keypair,
    );
  }

  late final _secp256k1_keypair_secPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_keypair>)>>('secp256k1_keypair_sec');
  late final _secp256k1_keypair_sec = _secp256k1_keypair_secPtr.asFunction<
      int Function(ffi.Pointer<secp256k1_context>,
          ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<secp256k1_keypair>)>();

  /// Get the public key from a keypair.
  ///
  /// Returns: 1 always.
  /// Args:   ctx: pointer to a context object.
  /// Out: pubkey: pointer to a pubkey object, set to the keypair public key.
  /// In: keypair: pointer to a keypair.
  int secp256k1_keypair_pub(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<secp256k1_keypair> keypair,
  ) {
    return _secp256k1_keypair_pub(
      ctx,
      pubkey,
      keypair,
    );
  }

  late final _secp256k1_keypair_pubPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<secp256k1_keypair>)>>('secp256k1_keypair_pub');
  late final _secp256k1_keypair_pub = _secp256k1_keypair_pubPtr.asFunction<
      int Function(ffi.Pointer<secp256k1_context>,
          ffi.Pointer<secp256k1_pubkey>, ffi.Pointer<secp256k1_keypair>)>();

  /// Get the x-only public key from a keypair.
  ///
  /// This is the same as calling secp256k1_keypair_pub and then
  /// secp256k1_xonly_pubkey_from_pubkey.
  ///
  /// Returns: 1 always.
  /// Args:   ctx: pointer to a context object.
  /// Out: pubkey: pointer to an xonly_pubkey object, set to the keypair
  /// public key after converting it to an xonly_pubkey.
  /// pk_parity: Ignored if NULL. Otherwise, pointer to an integer that will be set to the
  /// pk_parity argument of secp256k1_xonly_pubkey_from_pubkey.
  /// In: keypair: pointer to a keypair.
  int secp256k1_keypair_xonly_pub(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_xonly_pubkey> pubkey,
    ffi.Pointer<ffi.Int> pk_parity,
    ffi.Pointer<secp256k1_keypair> keypair,
  ) {
    return _secp256k1_keypair_xonly_pub(
      ctx,
      pubkey,
      pk_parity,
      keypair,
    );
  }

  late final _secp256k1_keypair_xonly_pubPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<secp256k1_keypair>)>>('secp256k1_keypair_xonly_pub');
  late final _secp256k1_keypair_xonly_pub =
      _secp256k1_keypair_xonly_pubPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<secp256k1_keypair>)>();

  /// Tweak a keypair by adding tweak32 to the secret key and updating the public
  /// key accordingly.
  ///
  /// Calling this function and then secp256k1_keypair_pub results in the same
  /// public key as calling secp256k1_keypair_xonly_pub and then
  /// secp256k1_xonly_pubkey_tweak_add.
  ///
  /// Returns: 0 if the arguments are invalid or the resulting keypair would be
  /// invalid (only when the tweak is the negation of the keypair's
  /// secret key). 1 otherwise.
  ///
  /// Args:       ctx: pointer to a context object.
  /// In/Out: keypair: pointer to a keypair to apply the tweak to. Will be set to
  /// an invalid value if this function returns 0.
  /// In:     tweak32: pointer to a 32-byte tweak, which must be valid according to
  /// secp256k1_ec_seckey_verify or 32 zero bytes. For uniformly
  /// random 32-byte tweaks, the chance of being invalid is
  /// negligible (around 1 in 2^128).
  int secp256k1_keypair_xonly_tweak_add(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_keypair> keypair,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_keypair_xonly_tweak_add(
      ctx,
      keypair,
      tweak32,
    );
  }

  late final _secp256k1_keypair_xonly_tweak_addPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_keypair>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_keypair_xonly_tweak_add');
  late final _secp256k1_keypair_xonly_tweak_add =
      _secp256k1_keypair_xonly_tweak_addPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_keypair>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// An implementation of the nonce generation function as defined in Bitcoin
  /// Improvement Proposal 340 "Schnorr Signatures for secp256k1"
  /// (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).
  ///
  /// If a data pointer is passed, it is assumed to be a pointer to 32 bytes of
  /// auxiliary random data as defined in BIP-340. If the data pointer is NULL,
  /// the nonce derivation procedure follows BIP-340 by setting the auxiliary
  /// random data to zero. The algo argument must be non-NULL, otherwise the
  /// function will fail and return 0. The hash will be tagged with algo.
  /// Therefore, to create BIP-340 compliant signatures, algo must be set to
  /// "BIP0340/nonce" and algolen to 13.
  late final ffi.Pointer<secp256k1_nonce_function_hardened>
      _secp256k1_nonce_function_bip340 =
      _lookup<secp256k1_nonce_function_hardened>(
          'secp256k1_nonce_function_bip340');

  secp256k1_nonce_function_hardened get secp256k1_nonce_function_bip340 =>
      _secp256k1_nonce_function_bip340.value;

  /// Create a Schnorr signature.
  ///
  /// Does _not_ strictly follow BIP-340 because it does not verify the resulting
  /// signature. Instead, you can manually use secp256k1_schnorrsig_verify and
  /// abort if it fails.
  ///
  /// This function only signs 32-byte messages. If you have messages of a
  /// different size (or the same size but without a context-specific tag
  /// prefix), it is recommended to create a 32-byte message hash with
  /// secp256k1_tagged_sha256 and then sign the hash. Tagged hashing allows
  /// providing an context-specific tag for domain separation. This prevents
  /// signatures from being valid in multiple contexts by accident.
  ///
  /// Returns 1 on success, 0 on failure.
  /// Args:    ctx: pointer to a context object (not secp256k1_context_static).
  /// Out:   sig64: pointer to a 64-byte array to store the serialized signature.
  /// In:    msg32: the 32-byte message being signed.
  /// keypair: pointer to an initialized keypair.
  /// aux_rand32: 32 bytes of fresh randomness. While recommended to provide
  /// this, it is only supplemental to security and can be NULL. A
  /// NULL argument is treated the same as an all-zero one. See
  /// BIP-340 "Default Signing" for a full explanation of this
  /// argument and for guidance if randomness is expensive.
  int secp256k1_schnorrsig_sign32(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> sig64,
    ffi.Pointer<ffi.UnsignedChar> msg32,
    ffi.Pointer<secp256k1_keypair> keypair,
    ffi.Pointer<ffi.UnsignedChar> aux_rand32,
  ) {
    return _secp256k1_schnorrsig_sign32(
      ctx,
      sig64,
      msg32,
      keypair,
      aux_rand32,
    );
  }

  late final _secp256k1_schnorrsig_sign32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_schnorrsig_sign32');
  late final _secp256k1_schnorrsig_sign32 =
      _secp256k1_schnorrsig_sign32Ptr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Same as secp256k1_schnorrsig_sign32, but DEPRECATED. Will be removed in
  /// future versions.
  int secp256k1_schnorrsig_sign(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> sig64,
    ffi.Pointer<ffi.UnsignedChar> msg32,
    ffi.Pointer<secp256k1_keypair> keypair,
    ffi.Pointer<ffi.UnsignedChar> aux_rand32,
  ) {
    return _secp256k1_schnorrsig_sign(
      ctx,
      sig64,
      msg32,
      keypair,
      aux_rand32,
    );
  }

  late final _secp256k1_schnorrsig_signPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_schnorrsig_sign');
  late final _secp256k1_schnorrsig_sign =
      _secp256k1_schnorrsig_signPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Create a Schnorr signature with a more flexible API.
  ///
  /// Same arguments as secp256k1_schnorrsig_sign except that it allows signing
  /// variable length messages and accepts a pointer to an extraparams object that
  /// allows customizing signing by passing additional arguments.
  ///
  /// Equivalent to secp256k1_schnorrsig_sign32(..., aux_rand32) if msglen is 32
  /// and extraparams is initialized as follows:
  /// ```
  /// secp256k1_schnorrsig_extraparams extraparams = SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT;
  /// extraparams.ndata = (unsigned char*)aux_rand32;
  /// ```
  ///
  /// Returns 1 on success, 0 on failure.
  /// Args:   ctx: pointer to a context object (not secp256k1_context_static).
  /// Out:  sig64: pointer to a 64-byte array to store the serialized signature.
  /// In:     msg: the message being signed. Can only be NULL if msglen is 0.
  /// msglen: length of the message.
  /// keypair: pointer to an initialized keypair.
  /// extraparams: pointer to an extraparams object (can be NULL).
  int secp256k1_schnorrsig_sign_custom(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> sig64,
    ffi.Pointer<ffi.UnsignedChar> msg,
    int msglen,
    ffi.Pointer<secp256k1_keypair> keypair,
    ffi.Pointer<secp256k1_schnorrsig_extraparams> extraparams,
  ) {
    return _secp256k1_schnorrsig_sign_custom(
      ctx,
      sig64,
      msg,
      msglen,
      keypair,
      extraparams,
    );
  }

  late final _secp256k1_schnorrsig_sign_customPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Size,
                  ffi.Pointer<secp256k1_keypair>,
                  ffi.Pointer<secp256k1_schnorrsig_extraparams>)>>(
      'secp256k1_schnorrsig_sign_custom');
  late final _secp256k1_schnorrsig_sign_custom =
      _secp256k1_schnorrsig_sign_customPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<secp256k1_schnorrsig_extraparams>)>();

  /// Verify a Schnorr signature.
  ///
  /// Returns: 1: correct signature
  /// 0: incorrect signature
  /// Args:    ctx: pointer to a context object.
  /// In:    sig64: pointer to the 64-byte signature to verify.
  /// msg: the message being verified. Can only be NULL if msglen is 0.
  /// msglen: length of the message
  /// pubkey: pointer to an x-only public key to verify with
  int secp256k1_schnorrsig_verify(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> sig64,
    ffi.Pointer<ffi.UnsignedChar> msg,
    int msglen,
    ffi.Pointer<secp256k1_xonly_pubkey> pubkey,
  ) {
    return _secp256k1_schnorrsig_verify(
      ctx,
      sig64,
      msg,
      msglen,
      pubkey,
    );
  }

  late final _secp256k1_schnorrsig_verifyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Size,
                  ffi.Pointer<secp256k1_xonly_pubkey>)>>(
      'secp256k1_schnorrsig_verify');
  late final _secp256k1_schnorrsig_verify =
      _secp256k1_schnorrsig_verifyPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<secp256k1_xonly_pubkey>)>();

  /// An implementation of SHA256 hash function that applies to compressed public key.
  /// Populates the output parameter with 32 bytes.
  late final ffi.Pointer<secp256k1_ecdh_hash_function>
      _secp256k1_ecdh_hash_function_sha256 =
      _lookup<secp256k1_ecdh_hash_function>(
          'secp256k1_ecdh_hash_function_sha256');

  secp256k1_ecdh_hash_function get secp256k1_ecdh_hash_function_sha256 =>
      _secp256k1_ecdh_hash_function_sha256.value;

  /// A default ECDH hash function (currently equal to secp256k1_ecdh_hash_function_sha256).
  /// Populates the output parameter with 32 bytes.
  late final ffi.Pointer<secp256k1_ecdh_hash_function>
      _secp256k1_ecdh_hash_function_default =
      _lookup<secp256k1_ecdh_hash_function>(
          'secp256k1_ecdh_hash_function_default');

  secp256k1_ecdh_hash_function get secp256k1_ecdh_hash_function_default =>
      _secp256k1_ecdh_hash_function_default.value;

  /// Compute an EC Diffie-Hellman secret in constant time
  ///
  /// Returns: 1: exponentiation was successful
  /// 0: scalar was invalid (zero or overflow) or hashfp returned 0
  /// Args:    ctx:        pointer to a context object.
  /// Out:     output:     pointer to an array to be filled by hashfp.
  /// In:      pubkey:     pointer to a secp256k1_pubkey containing an initialized public key.
  /// seckey:     a 32-byte scalar with which to multiply the point.
  /// hashfp:     pointer to a hash function. If NULL,
  /// secp256k1_ecdh_hash_function_sha256 is used
  /// (in which case, 32 bytes will be written to output).
  /// data:       arbitrary data pointer that is passed through to hashfp
  /// (can be NULL for secp256k1_ecdh_hash_function_sha256).
  int secp256k1_ecdh(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> output,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    secp256k1_ecdh_hash_function hashfp,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _secp256k1_ecdh(
      ctx,
      output,
      pubkey,
      seckey,
      hashfp,
      data,
    );
  }

  late final _secp256k1_ecdhPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>,
              secp256k1_ecdh_hash_function,
              ffi.Pointer<ffi.Void>)>>('secp256k1_ecdh');
  late final _secp256k1_ecdh = _secp256k1_ecdhPtr.asFunction<
      int Function(
          ffi.Pointer<secp256k1_context>,
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<secp256k1_pubkey>,
          ffi.Pointer<ffi.UnsignedChar>,
          secp256k1_ecdh_hash_function,
          ffi.Pointer<ffi.Void>)>();
}

final class max_align_t extends ffi.Opaque {}

final class secp256k1_context_struct extends ffi.Opaque {}

final class secp256k1_scratch_space_struct extends ffi.Opaque {}

/// Opaque data structure that holds a parsed and valid public key.
///
/// The exact representation of data inside is implementation defined and not
/// guaranteed to be portable between different platforms or versions. It is
/// however guaranteed to be 64 bytes in size, and can be safely copied/moved.
/// If you need to convert to a format suitable for storage or transmission,
/// use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse. To
/// compare keys, use secp256k1_ec_pubkey_cmp.
final class secp256k1_pubkey extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// Opaque data structured that holds a parsed ECDSA signature.
///
/// The exact representation of data inside is implementation defined and not
/// guaranteed to be portable between different platforms or versions. It is
/// however guaranteed to be 64 bytes in size, and can be safely copied/moved.
/// If you need to convert to a format suitable for storage, transmission, or
/// comparison, use the secp256k1_ecdsa_signature_serialize_* and
/// secp256k1_ecdsa_signature_parse_* functions.
final class secp256k1_ecdsa_signature extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// Opaque data structure that holds context information
///
/// The primary purpose of context objects is to store randomization data for
/// enhanced protection against side-channel leakage. This protection is only
/// effective if the context is randomized after its creation. See
/// secp256k1_context_create for creation of contexts and
/// secp256k1_context_randomize for randomization.
///
/// A secondary purpose of context objects is to store pointers to callback
/// functions that the library will call when certain error states arise. See
/// secp256k1_context_set_error_callback as well as
/// secp256k1_context_set_illegal_callback for details. Future library versions
/// may use context objects for additional purposes.
///
/// A constructed context can safely be used from multiple threads
/// simultaneously, but API calls that take a non-const pointer to a context
/// need exclusive access to it. In particular this is the case for
/// secp256k1_context_destroy, secp256k1_context_preallocated_destroy,
/// and secp256k1_context_randomize.
///
/// Regarding randomization, either do it once at creation time (in which case
/// you do not need any locking for the other calls), or use a read-write lock.
typedef secp256k1_context = secp256k1_context_struct;

/// Opaque data structure that holds rewritable "scratch space"
///
/// The purpose of this structure is to replace dynamic memory allocations,
/// because we target architectures where this may not be available. It is
/// essentially a resizable (within specified parameters) block of bytes,
/// which is initially created either by memory allocation or TODO as a pointer
/// into some fixed rewritable space.
///
/// Unlike the context object, this cannot safely be shared between threads
/// without additional synchronization logic.
typedef secp256k1_scratch_space = secp256k1_scratch_space_struct;

/// A pointer to a function to deterministically generate a nonce.
///
/// Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.
/// Out:     nonce32:   pointer to a 32-byte array to be filled by the function.
/// In:      msg32:     the 32-byte message hash being verified (will not be NULL)
/// key32:     pointer to a 32-byte secret key (will not be NULL)
/// algo16:    pointer to a 16-byte array describing the signature
/// algorithm (will be NULL for ECDSA for compatibility).
/// data:      Arbitrary data pointer that is passed through.
/// attempt:   how many iterations we have tried to find a nonce.
/// This will almost always be 0, but different attempt values
/// are required to result in a different nonce.
///
/// Except for test cases, this function should compute some cryptographic hash of
/// the message, the algorithm, the key and the attempt.
typedef secp256k1_nonce_function
    = ffi.Pointer<ffi.NativeFunction<secp256k1_nonce_functionFunction>>;
typedef secp256k1_nonce_functionFunction = ffi.Int Function(
    ffi.Pointer<ffi.UnsignedChar> nonce32,
    ffi.Pointer<ffi.UnsignedChar> msg32,
    ffi.Pointer<ffi.UnsignedChar> key32,
    ffi.Pointer<ffi.UnsignedChar> algo16,
    ffi.Pointer<ffi.Void> data,
    ffi.UnsignedInt attempt);
typedef Dartsecp256k1_nonce_functionFunction = int Function(
    ffi.Pointer<ffi.UnsignedChar> nonce32,
    ffi.Pointer<ffi.UnsignedChar> msg32,
    ffi.Pointer<ffi.UnsignedChar> key32,
    ffi.Pointer<ffi.UnsignedChar> algo16,
    ffi.Pointer<ffi.Void> data,
    int attempt);

/// Opaque data structured that holds a parsed ECDSA signature,
/// supporting pubkey recovery.
///
/// The exact representation of data inside is implementation defined and not
/// guaranteed to be portable between different platforms or versions. It is
/// however guaranteed to be 65 bytes in size, and can be safely copied/moved.
/// If you need to convert to a format suitable for storage or transmission, use
/// the secp256k1_ecdsa_signature_serialize_* and
/// secp256k1_ecdsa_signature_parse_* functions.
///
/// Furthermore, it is guaranteed that identical signatures (including their
/// recoverability) will have identical representation, so they can be
/// memcmp'ed.
final class secp256k1_ecdsa_recoverable_signature extends ffi.Struct {
  @ffi.Array.multi([65])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// Opaque data structure that holds a parsed and valid "x-only" public key.
/// An x-only pubkey encodes a point whose Y coordinate is even. It is
/// serialized using only its X coordinate (32 bytes). See BIP-340 for more
/// information about x-only pubkeys.
///
/// The exact representation of data inside is implementation defined and not
/// guaranteed to be portable between different platforms or versions. It is
/// however guaranteed to be 64 bytes in size, and can be safely copied/moved.
/// If you need to convert to a format suitable for storage, transmission, use
/// use secp256k1_xonly_pubkey_serialize and secp256k1_xonly_pubkey_parse. To
/// compare keys, use secp256k1_xonly_pubkey_cmp.
final class secp256k1_xonly_pubkey extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// Opaque data structure that holds a keypair consisting of a secret and a
/// public key.
///
/// The exact representation of data inside is implementation defined and not
/// guaranteed to be portable between different platforms or versions. It is
/// however guaranteed to be 96 bytes in size, and can be safely copied/moved.
final class secp256k1_keypair extends ffi.Struct {
  @ffi.Array.multi([96])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// A pointer to a function to deterministically generate a nonce.
///
/// Same as secp256k1_nonce function with the exception of accepting an
/// additional pubkey argument and not requiring an attempt argument. The pubkey
/// argument can protect signature schemes with key-prefixed challenge hash
/// inputs against reusing the nonce when signing with the wrong precomputed
/// pubkey.
///
/// Returns: 1 if a nonce was successfully generated. 0 will cause signing to
/// return an error.
/// Out:  nonce32: pointer to a 32-byte array to be filled by the function
/// In:       msg: the message being verified. Is NULL if and only if msglen
/// is 0.
/// msglen: the length of the message
/// key32: pointer to a 32-byte secret key (will not be NULL)
/// xonly_pk32: the 32-byte serialized xonly pubkey corresponding to key32
/// (will not be NULL)
/// algo: pointer to an array describing the signature
/// algorithm (will not be NULL)
/// algolen: the length of the algo array
/// data: arbitrary data pointer that is passed through
///
/// Except for test cases, this function should compute some cryptographic hash of
/// the message, the key, the pubkey, the algorithm description, and data.
typedef secp256k1_nonce_function_hardened = ffi
    .Pointer<ffi.NativeFunction<secp256k1_nonce_function_hardenedFunction>>;
typedef secp256k1_nonce_function_hardenedFunction = ffi.Int Function(
    ffi.Pointer<ffi.UnsignedChar> nonce32,
    ffi.Pointer<ffi.UnsignedChar> msg,
    ffi.Size msglen,
    ffi.Pointer<ffi.UnsignedChar> key32,
    ffi.Pointer<ffi.UnsignedChar> xonly_pk32,
    ffi.Pointer<ffi.UnsignedChar> algo,
    ffi.Size algolen,
    ffi.Pointer<ffi.Void> data);
typedef Dartsecp256k1_nonce_function_hardenedFunction = int Function(
    ffi.Pointer<ffi.UnsignedChar> nonce32,
    ffi.Pointer<ffi.UnsignedChar> msg,
    int msglen,
    ffi.Pointer<ffi.UnsignedChar> key32,
    ffi.Pointer<ffi.UnsignedChar> xonly_pk32,
    ffi.Pointer<ffi.UnsignedChar> algo,
    int algolen,
    ffi.Pointer<ffi.Void> data);

/// Data structure that contains additional arguments for schnorrsig_sign_custom.
///
/// A schnorrsig_extraparams structure object can be initialized correctly by
/// setting it to SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT.
///
/// Members:
/// magic: set to SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC at initialization
/// and has no other function than making sure the object is
/// initialized.
/// noncefp: pointer to a nonce generation function. If NULL,
/// secp256k1_nonce_function_bip340 is used
/// ndata: pointer to arbitrary data used by the nonce generation function
/// (can be NULL). If it is non-NULL and
/// secp256k1_nonce_function_bip340 is used, then ndata must be a
/// pointer to 32-byte auxiliary randomness as per BIP-340.
final class secp256k1_schnorrsig_extraparams extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedChar> magic;

  external secp256k1_nonce_function_hardened noncefp;

  external ffi.Pointer<ffi.Void> ndata;
}

/// A pointer to a function that hashes an EC point to obtain an ECDH secret
///
/// Returns: 1 if the point was successfully hashed.
/// 0 will cause secp256k1_ecdh to fail and return 0.
/// Other return values are not allowed, and the behaviour of
/// secp256k1_ecdh is undefined for other return values.
/// Out:     output:     pointer to an array to be filled by the function
/// In:      x32:        pointer to a 32-byte x coordinate
/// y32:        pointer to a 32-byte y coordinate
/// data:       arbitrary data pointer that is passed through
typedef secp256k1_ecdh_hash_function
    = ffi.Pointer<ffi.NativeFunction<secp256k1_ecdh_hash_functionFunction>>;
typedef secp256k1_ecdh_hash_functionFunction = ffi.Int Function(
    ffi.Pointer<ffi.UnsignedChar> output,
    ffi.Pointer<ffi.UnsignedChar> x32,
    ffi.Pointer<ffi.UnsignedChar> y32,
    ffi.Pointer<ffi.Void> data);
typedef Dartsecp256k1_ecdh_hash_functionFunction = int Function(
    ffi.Pointer<ffi.UnsignedChar> output,
    ffi.Pointer<ffi.UnsignedChar> x32,
    ffi.Pointer<ffi.UnsignedChar> y32,
    ffi.Pointer<ffi.Void> data);

const int NULL = 0;

const int SECP256K1_FLAGS_TYPE_MASK = 255;

const int SECP256K1_FLAGS_TYPE_CONTEXT = 1;

const int SECP256K1_FLAGS_TYPE_COMPRESSION = 2;

const int SECP256K1_FLAGS_BIT_CONTEXT_VERIFY = 256;

const int SECP256K1_FLAGS_BIT_CONTEXT_SIGN = 512;

const int SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY = 1024;

const int SECP256K1_FLAGS_BIT_COMPRESSION = 256;

const int SECP256K1_CONTEXT_NONE = 1;

const int SECP256K1_CONTEXT_VERIFY = 257;

const int SECP256K1_CONTEXT_SIGN = 513;

const int SECP256K1_CONTEXT_DECLASSIFY = 1025;

const int SECP256K1_EC_COMPRESSED = 258;

const int SECP256K1_EC_UNCOMPRESSED = 2;

const int SECP256K1_TAG_PUBKEY_EVEN = 2;

const int SECP256K1_TAG_PUBKEY_ODD = 3;

const int SECP256K1_TAG_PUBKEY_UNCOMPRESSED = 4;

const int SECP256K1_TAG_PUBKEY_HYBRID_EVEN = 6;

const int SECP256K1_TAG_PUBKEY_HYBRID_ODD = 7;
