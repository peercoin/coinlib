// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Raw generated bindings to secp256k1
class NativeSecp256k1 {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeSecp256k1(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeSecp256k1.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// A built-in constant secp256k1 context object with static storage duration, to be
  /// used in conjunction with secp256k1_selftest.
  ///
  /// This context object offers *only limited functionality* , i.e., it cannot be used
  /// for API functions that perform computations involving secret keys, e.g., signing
  /// and public key generation. If this restriction applies to a specific API function,
  /// it is mentioned in its documentation. See secp256k1_context_create if you need a
  /// full context object that supports all functionality offered by the library.
  ///
  /// It is highly recommended to call secp256k1_selftest before using this context.
  late final ffi.Pointer<ffi.Pointer<secp256k1_context>>
      _secp256k1_context_static =
      _lookup<ffi.Pointer<secp256k1_context>>('secp256k1_context_static');

  ffi.Pointer<secp256k1_context> get secp256k1_context_static =>
      _secp256k1_context_static.value;

  /// Deprecated alias for secp256k1_context_static.
  late final ffi.Pointer<ffi.Pointer<secp256k1_context>>
      _secp256k1_context_no_precomp =
      _lookup<ffi.Pointer<secp256k1_context>>('secp256k1_context_no_precomp');

  ffi.Pointer<secp256k1_context> get secp256k1_context_no_precomp =>
      _secp256k1_context_no_precomp.value;

  /// Perform basic self tests (to be used in conjunction with secp256k1_context_static)
  ///
  /// This function performs self tests that detect some serious usage errors and
  /// similar conditions, e.g., when the library is compiled for the wrong endianness.
  /// This is a last resort measure to be used in production. The performed tests are
  /// very rudimentary and are not intended as a replacement for running the test
  /// binaries.
  ///
  /// It is highly recommended to call this before using secp256k1_context_static.
  /// It is not necessary to call this function before using a context created with
  /// secp256k1_context_create (or secp256k1_context_preallocated_create), which will
  /// take care of performing the self tests.
  ///
  /// If the tests fail, this function will call the default error handler to abort the
  /// program (see secp256k1_context_set_error_callback).
  void secp256k1_selftest() {
    return _secp256k1_selftest();
  }

  late final _secp256k1_selftestPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('secp256k1_selftest');
  late final _secp256k1_selftest =
      _secp256k1_selftestPtr.asFunction<void Function()>();

  /// Create a secp256k1 context object (in dynamically allocated memory).
  ///
  /// This function uses malloc to allocate memory. It is guaranteed that malloc is
  /// called at most once for every call of this function. If you need to avoid dynamic
  /// memory allocation entirely, see secp256k1_context_static and the functions in
  /// secp256k1_preallocated.h.
  ///
  /// Returns: pointer to a newly created context object.
  /// In:      flags: Always set to SECP256K1_CONTEXT_NONE (see below).
  ///
  /// The only valid non-deprecated flag in recent library versions is
  /// SECP256K1_CONTEXT_NONE, which will create a context sufficient for all functionality
  /// offered by the library. All other (deprecated) flags will be treated as equivalent
  /// to the SECP256K1_CONTEXT_NONE flag. Though the flags parameter primarily exists for
  /// historical reasons, future versions of the library may introduce new flags.
  ///
  /// If the context is intended to be used for API functions that perform computations
  /// involving secret keys, e.g., signing and public key generation, then it is highly
  /// recommended to call secp256k1_context_randomize on the context before calling
  /// those API functions. This will provide enhanced protection against side-channel
  /// leakage, see secp256k1_context_randomize for details.
  ///
  /// Do not create a new context object for each operation, as construction and
  /// randomization can take non-negligible time.
  ffi.Pointer<secp256k1_context> secp256k1_context_create(
    int flags,
  ) {
    return _secp256k1_context_create(
      flags,
    );
  }

  late final _secp256k1_context_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<secp256k1_context> Function(
              ffi.UnsignedInt)>>('secp256k1_context_create');
  late final _secp256k1_context_create = _secp256k1_context_createPtr
      .asFunction<ffi.Pointer<secp256k1_context> Function(int)>();

  /// Copy a secp256k1 context object (into dynamically allocated memory).
  ///
  /// This function uses malloc to allocate memory. It is guaranteed that malloc is
  /// called at most once for every call of this function. If you need to avoid dynamic
  /// memory allocation entirely, see the functions in secp256k1_preallocated.h.
  ///
  /// Cloning secp256k1_context_static is not possible, and should not be emulated by
  /// the caller (e.g., using memcpy). Create a new context instead.
  ///
  /// Returns: pointer to a newly created context object.
  /// Args:    ctx: pointer to a context to copy (not secp256k1_context_static).
  ffi.Pointer<secp256k1_context> secp256k1_context_clone(
    ffi.Pointer<secp256k1_context> ctx,
  ) {
    return _secp256k1_context_clone(
      ctx,
    );
  }

  late final _secp256k1_context_clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<secp256k1_context> Function(
              ffi.Pointer<secp256k1_context>)>>('secp256k1_context_clone');
  late final _secp256k1_context_clone = _secp256k1_context_clonePtr.asFunction<
      ffi.Pointer<secp256k1_context> Function(
          ffi.Pointer<secp256k1_context>)>();

  /// Destroy a secp256k1 context object (created in dynamically allocated memory).
  ///
  /// The context pointer may not be used afterwards.
  ///
  /// The context to destroy must have been created using secp256k1_context_create
  /// or secp256k1_context_clone. If the context has instead been created using
  /// secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone, the
  /// behaviour is undefined. In that case, secp256k1_context_preallocated_destroy must
  /// be used instead.
  ///
  /// Args:   ctx: pointer to a context to destroy, constructed using
  /// secp256k1_context_create or secp256k1_context_clone
  /// (i.e., not secp256k1_context_static).
  void secp256k1_context_destroy(
    ffi.Pointer<secp256k1_context> ctx,
  ) {
    return _secp256k1_context_destroy(
      ctx,
    );
  }

  late final _secp256k1_context_destroyPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<secp256k1_context>)>>(
      'secp256k1_context_destroy');
  late final _secp256k1_context_destroy = _secp256k1_context_destroyPtr
      .asFunction<void Function(ffi.Pointer<secp256k1_context>)>();

  /// Set a callback function to be called when an illegal argument is passed to
  /// an API call. It will only trigger for violations that are mentioned
  /// explicitly in the header.
  ///
  /// The philosophy is that these shouldn't be dealt with through a
  /// specific return value, as calling code should not have branches to deal with
  /// the case that this code itself is broken.
  ///
  /// On the other hand, during debug stage, one would want to be informed about
  /// such mistakes, and the default (crashing) may be inadvisable.
  /// When this callback is triggered, the API function called is guaranteed not
  /// to cause a crash, though its return value and output arguments are
  /// undefined.
  ///
  /// When this function has not been called (or called with fn==NULL), then the
  /// default handler will be used. The library provides a default handler which
  /// writes the message to stderr and calls abort. This default handler can be
  /// replaced at link time if the preprocessor macro
  /// USE_EXTERNAL_DEFAULT_CALLBACKS is defined, which is the case if the build
  /// has been configured with --enable-external-default-callbacks. Then the
  /// following two symbols must be provided to link against:
  /// - void secp256k1_default_illegal_callback_fn(const char *message, void *data);
  /// - void secp256k1_default_error_callback_fn(const char *message, void *data);
  /// The library can call these default handlers even before a proper callback data
  /// pointer could have been set using secp256k1_context_set_illegal_callback or
  /// secp256k1_context_set_error_callback, e.g., when the creation of a context
  /// fails. In this case, the corresponding default handler will be called with
  /// the data pointer argument set to NULL.
  ///
  /// Args: ctx:  pointer to a context object.
  /// In:   fun:  pointer to a function to call when an illegal argument is
  /// passed to the API, taking a message and an opaque pointer.
  /// (NULL restores the default handler.)
  /// data: the opaque pointer to pass to fun above, must be NULL for the default handler.
  ///
  /// See also secp256k1_context_set_error_callback.
  void secp256k1_context_set_illegal_callback(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Char> message, ffi.Pointer<ffi.Void> data)>>
        fun,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _secp256k1_context_set_illegal_callback(
      ctx,
      fun,
      data,
    );
  }

  late final _secp256k1_context_set_illegal_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Char> message,
                              ffi.Pointer<ffi.Void> data)>>,
                  ffi.Pointer<ffi.Void>)>>(
      'secp256k1_context_set_illegal_callback');
  late final _secp256k1_context_set_illegal_callback =
      _secp256k1_context_set_illegal_callbackPtr.asFunction<
          void Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Char> message,
                          ffi.Pointer<ffi.Void> data)>>,
              ffi.Pointer<ffi.Void>)>();

  /// Set a callback function to be called when an internal consistency check
  /// fails.
  ///
  /// The default callback writes an error message to stderr and calls abort
  /// to abort the program.
  ///
  /// This can only trigger in case of a hardware failure, miscompilation,
  /// memory corruption, serious bug in the library, or other error would can
  /// otherwise result in undefined behaviour. It will not trigger due to mere
  /// incorrect usage of the API (see secp256k1_context_set_illegal_callback
  /// for that). After this callback returns, anything may happen, including
  /// crashing.
  ///
  /// Args: ctx:  pointer to a context object.
  /// In:   fun:  pointer to a function to call when an internal error occurs,
  /// taking a message and an opaque pointer (NULL restores the
  /// default handler, see secp256k1_context_set_illegal_callback
  /// for details).
  /// data: the opaque pointer to pass to fun above, must be NULL for the default handler.
  ///
  /// See also secp256k1_context_set_illegal_callback.
  void secp256k1_context_set_error_callback(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Char> message, ffi.Pointer<ffi.Void> data)>>
        fun,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _secp256k1_context_set_error_callback(
      ctx,
      fun,
      data,
    );
  }

  late final _secp256k1_context_set_error_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Char> message,
                          ffi.Pointer<ffi.Void> data)>>,
              ffi.Pointer<ffi.Void>)>>('secp256k1_context_set_error_callback');
  late final _secp256k1_context_set_error_callback =
      _secp256k1_context_set_error_callbackPtr.asFunction<
          void Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Char> message,
                          ffi.Pointer<ffi.Void> data)>>,
              ffi.Pointer<ffi.Void>)>();

  /// Parse a variable-length public key into the pubkey object.
  ///
  /// Returns: 1 if the public key was fully valid.
  /// 0 if the public key could not be parsed or is invalid.
  /// Args: ctx:      pointer to a context object.
  /// Out:  pubkey:   pointer to a pubkey object. If 1 is returned, it is set to a
  /// parsed version of input. If not, its value is undefined.
  /// In:   input:    pointer to a serialized public key
  /// inputlen: length of the array pointed to by input
  ///
  /// This function supports parsing compressed (33 bytes, header byte 0x02 or
  /// 0x03), uncompressed (65 bytes, header byte 0x04), or hybrid (65 bytes, header
  /// byte 0x06 or 0x07) format public keys.
  int secp256k1_ec_pubkey_parse(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<ffi.UnsignedChar> input,
    int inputlen,
  ) {
    return _secp256k1_ec_pubkey_parse(
      ctx,
      pubkey,
      input,
      inputlen,
    );
  }

  late final _secp256k1_ec_pubkey_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('secp256k1_ec_pubkey_parse');
  late final _secp256k1_ec_pubkey_parse =
      _secp256k1_ec_pubkey_parsePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>,
              int)>();

  /// Serialize a pubkey object into a serialized byte sequence.
  ///
  /// Returns: 1 always.
  /// Args:   ctx:        pointer to a context object.
  /// Out:    output:     pointer to a 65-byte (if compressed==0) or 33-byte (if
  /// compressed==1) byte array to place the serialized key
  /// in.
  /// In/Out: outputlen:  pointer to an integer which is initially set to the
  /// size of output, and is overwritten with the written
  /// size.
  /// In:     pubkey:     pointer to a secp256k1_pubkey containing an
  /// initialized public key.
  /// flags:      SECP256K1_EC_COMPRESSED if serialization should be in
  /// compressed format, otherwise SECP256K1_EC_UNCOMPRESSED.
  int secp256k1_ec_pubkey_serialize(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> output,
    ffi.Pointer<ffi.Size> outputlen,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    int flags,
  ) {
    return _secp256k1_ec_pubkey_serialize(
      ctx,
      output,
      outputlen,
      pubkey,
      flags,
    );
  }

  late final _secp256k1_ec_pubkey_serializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.UnsignedInt)>>('secp256k1_ec_pubkey_serialize');
  late final _secp256k1_ec_pubkey_serialize =
      _secp256k1_ec_pubkey_serializePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<secp256k1_pubkey>,
              int)>();

  /// Compare two public keys using lexicographic (of compressed serialization) order
  ///
  /// Returns: <0 if the first public key is less than the second
  /// >0 if the first public key is greater than the second
  /// 0 if the two public keys are equal
  /// Args: ctx:      pointer to a context object
  /// In:   pubkey1:  first public key to compare
  /// pubkey2:  second public key to compare
  int secp256k1_ec_pubkey_cmp(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey1,
    ffi.Pointer<secp256k1_pubkey> pubkey2,
  ) {
    return _secp256k1_ec_pubkey_cmp(
      ctx,
      pubkey1,
      pubkey2,
    );
  }

  late final _secp256k1_ec_pubkey_cmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<secp256k1_pubkey>)>>('secp256k1_ec_pubkey_cmp');
  late final _secp256k1_ec_pubkey_cmp = _secp256k1_ec_pubkey_cmpPtr.asFunction<
      int Function(ffi.Pointer<secp256k1_context>,
          ffi.Pointer<secp256k1_pubkey>, ffi.Pointer<secp256k1_pubkey>)>();

  /// Sort public keys using lexicographic (of compressed serialization) order
  ///
  /// Returns: 0 if the arguments are invalid. 1 otherwise.
  ///
  /// Args:     ctx: pointer to a context object
  /// In:   pubkeys: array of pointers to pubkeys to sort
  /// n_pubkeys: number of elements in the pubkeys array
  int secp256k1_ec_pubkey_sort(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.Pointer<secp256k1_pubkey>> pubkeys,
    int n_pubkeys,
  ) {
    return _secp256k1_ec_pubkey_sort(
      ctx,
      pubkeys,
      n_pubkeys,
    );
  }

  late final _secp256k1_ec_pubkey_sortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.Pointer<secp256k1_pubkey>>,
              ffi.Size)>>('secp256k1_ec_pubkey_sort');
  late final _secp256k1_ec_pubkey_sort =
      _secp256k1_ec_pubkey_sortPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.Pointer<secp256k1_pubkey>>, int)>();

  /// Parse an ECDSA signature in compact (64 bytes) format.
  ///
  /// Returns: 1 when the signature could be parsed, 0 otherwise.
  /// Args: ctx:      pointer to a context object
  /// Out:  sig:      pointer to a signature object
  /// In:   input64:  pointer to the 64-byte array to parse
  ///
  /// The signature must consist of a 32-byte big endian R value, followed by a
  /// 32-byte big endian S value. If R or S fall outside of [0..order-1], the
  /// encoding is invalid. R and S with value 0 are allowed in the encoding.
  ///
  /// After the call, sig will always be initialized. If parsing failed or R or
  /// S are zero, the resulting sig value is guaranteed to fail verification for
  /// any message and public key.
  int secp256k1_ecdsa_signature_parse_compact(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> input64,
  ) {
    return _secp256k1_ecdsa_signature_parse_compact(
      ctx,
      sig,
      input64,
    );
  }

  late final _secp256k1_ecdsa_signature_parse_compactPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_ecdsa_signature>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_ecdsa_signature_parse_compact');
  late final _secp256k1_ecdsa_signature_parse_compact =
      _secp256k1_ecdsa_signature_parse_compactPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Parse a DER ECDSA signature.
  ///
  /// Returns: 1 when the signature could be parsed, 0 otherwise.
  /// Args: ctx:      pointer to a context object
  /// Out:  sig:      pointer to a signature object
  /// In:   input:    pointer to the signature to be parsed
  /// inputlen: the length of the array pointed to be input
  ///
  /// This function will accept any valid DER encoded signature, even if the
  /// encoded numbers are out of range.
  ///
  /// After the call, sig will always be initialized. If parsing failed or the
  /// encoded numbers are out of range, signature verification with it is
  /// guaranteed to fail for every message and public key.
  int secp256k1_ecdsa_signature_parse_der(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> input,
    int inputlen,
  ) {
    return _secp256k1_ecdsa_signature_parse_der(
      ctx,
      sig,
      input,
      inputlen,
    );
  }

  late final _secp256k1_ecdsa_signature_parse_derPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('secp256k1_ecdsa_signature_parse_der');
  late final _secp256k1_ecdsa_signature_parse_der =
      _secp256k1_ecdsa_signature_parse_derPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              int)>();

  /// Serialize an ECDSA signature in DER format.
  ///
  /// Returns: 1 if enough space was available to serialize, 0 otherwise
  /// Args:   ctx:       pointer to a context object
  /// Out:    output:    pointer to an array to store the DER serialization
  /// In/Out: outputlen: pointer to a length integer. Initially, this integer
  /// should be set to the length of output. After the call
  /// it will be set to the length of the serialization (even
  /// if 0 was returned).
  /// In:     sig:       pointer to an initialized signature object
  int secp256k1_ecdsa_signature_serialize_der(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> output,
    ffi.Pointer<ffi.Size> outputlen,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
  ) {
    return _secp256k1_ecdsa_signature_serialize_der(
      ctx,
      output,
      outputlen,
      sig,
    );
  }

  late final _secp256k1_ecdsa_signature_serialize_derPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<ffi.Size>,
                  ffi.Pointer<secp256k1_ecdsa_signature>)>>(
      'secp256k1_ecdsa_signature_serialize_der');
  late final _secp256k1_ecdsa_signature_serialize_der =
      _secp256k1_ecdsa_signature_serialize_derPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<secp256k1_ecdsa_signature>)>();

  /// Serialize an ECDSA signature in compact (64 byte) format.
  ///
  /// Returns: 1
  /// Args:   ctx:       pointer to a context object
  /// Out:    output64:  pointer to a 64-byte array to store the compact serialization
  /// In:     sig:       pointer to an initialized signature object
  ///
  /// See secp256k1_ecdsa_signature_parse_compact for details about the encoding.
  int secp256k1_ecdsa_signature_serialize_compact(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> output64,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
  ) {
    return _secp256k1_ecdsa_signature_serialize_compact(
      ctx,
      output64,
      sig,
    );
  }

  late final _secp256k1_ecdsa_signature_serialize_compactPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<secp256k1_ecdsa_signature>)>>(
      'secp256k1_ecdsa_signature_serialize_compact');
  late final _secp256k1_ecdsa_signature_serialize_compact =
      _secp256k1_ecdsa_signature_serialize_compactPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_ecdsa_signature>)>();

  /// Verify an ECDSA signature.
  ///
  /// Returns: 1: correct signature
  /// 0: incorrect or unparseable signature
  /// Args:    ctx:       pointer to a context object
  /// In:      sig:       the signature being verified.
  /// msghash32: the 32-byte message hash being verified.
  /// The verifier must make sure to apply a cryptographic
  /// hash function to the message by itself and not accept an
  /// msghash32 value directly. Otherwise, it would be easy to
  /// create a "valid" signature without knowledge of the
  /// secret key. See also
  /// https://bitcoin.stackexchange.com/a/81116/35586 for more
  /// background on this topic.
  /// pubkey:    pointer to an initialized public key to verify with.
  ///
  /// To avoid accepting malleable signatures, only ECDSA signatures in lower-S
  /// form are accepted.
  ///
  /// If you need to accept ECDSA signatures from sources that do not obey this
  /// rule, apply secp256k1_ecdsa_signature_normalize to the signature prior to
  /// verification, but be aware that doing so results in malleable signatures.
  ///
  /// For details, see the comments for that function.
  int secp256k1_ecdsa_verify(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> msghash32,
    ffi.Pointer<secp256k1_pubkey> pubkey,
  ) {
    return _secp256k1_ecdsa_verify(
      ctx,
      sig,
      msghash32,
      pubkey,
    );
  }

  late final _secp256k1_ecdsa_verifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_pubkey>)>>('secp256k1_ecdsa_verify');
  late final _secp256k1_ecdsa_verify = _secp256k1_ecdsa_verifyPtr.asFunction<
      int Function(
          ffi.Pointer<secp256k1_context>,
          ffi.Pointer<secp256k1_ecdsa_signature>,
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<secp256k1_pubkey>)>();

  /// Convert a signature to a normalized lower-S form.
  ///
  /// Returns: 1 if sigin was not normalized, 0 if it already was.
  /// Args: ctx:    pointer to a context object
  /// Out:  sigout: pointer to a signature to fill with the normalized form,
  /// or copy if the input was already normalized. (can be NULL if
  /// you're only interested in whether the input was already
  /// normalized).
  /// In:   sigin:  pointer to a signature to check/normalize (can be identical to sigout)
  ///
  /// With ECDSA a third-party can forge a second distinct signature of the same
  /// message, given a single initial signature, but without knowing the key. This
  /// is done by negating the S value modulo the order of the curve, 'flipping'
  /// the sign of the random point R which is not included in the signature.
  ///
  /// Forgery of the same message isn't universally problematic, but in systems
  /// where message malleability or uniqueness of signatures is important this can
  /// cause issues. This forgery can be blocked by all verifiers forcing signers
  /// to use a normalized form.
  ///
  /// The lower-S form reduces the size of signatures slightly on average when
  /// variable length encodings (such as DER) are used and is cheap to verify,
  /// making it a good choice. Security of always using lower-S is assured because
  /// anyone can trivially modify a signature after the fact to enforce this
  /// property anyway.
  ///
  /// The lower S value is always between 0x1 and
  /// 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,
  /// inclusive.
  ///
  /// No other forms of ECDSA malleability are known and none seem likely, but
  /// there is no formal proof that ECDSA, even with this additional restriction,
  /// is free of other malleability. Commonly used serialization schemes will also
  /// accept various non-unique encodings, so care should be taken when this
  /// property is required for an application.
  ///
  /// The secp256k1_ecdsa_sign function will by default create signatures in the
  /// lower-S form, and secp256k1_ecdsa_verify will not accept others. In case
  /// signatures come from a system that cannot enforce this property,
  /// secp256k1_ecdsa_signature_normalize must be called before verification.
  int secp256k1_ecdsa_signature_normalize(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_signature> sigout,
    ffi.Pointer<secp256k1_ecdsa_signature> sigin,
  ) {
    return _secp256k1_ecdsa_signature_normalize(
      ctx,
      sigout,
      sigin,
    );
  }

  late final _secp256k1_ecdsa_signature_normalizePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_ecdsa_signature>,
                  ffi.Pointer<secp256k1_ecdsa_signature>)>>(
      'secp256k1_ecdsa_signature_normalize');
  late final _secp256k1_ecdsa_signature_normalize =
      _secp256k1_ecdsa_signature_normalizePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<secp256k1_ecdsa_signature>)>();

  /// An implementation of RFC6979 (using HMAC-SHA256) as nonce generation function.
  /// If a data pointer is passed, it is assumed to be a pointer to 32 bytes of
  /// extra entropy.
  late final ffi.Pointer<secp256k1_nonce_function>
      _secp256k1_nonce_function_rfc6979 =
      _lookup<secp256k1_nonce_function>('secp256k1_nonce_function_rfc6979');

  secp256k1_nonce_function get secp256k1_nonce_function_rfc6979 =>
      _secp256k1_nonce_function_rfc6979.value;

  /// A default safe nonce generation function (currently equal to secp256k1_nonce_function_rfc6979).
  late final ffi.Pointer<secp256k1_nonce_function>
      _secp256k1_nonce_function_default =
      _lookup<secp256k1_nonce_function>('secp256k1_nonce_function_default');

  secp256k1_nonce_function get secp256k1_nonce_function_default =>
      _secp256k1_nonce_function_default.value;

  /// Create an ECDSA signature.
  ///
  /// Returns: 1: signature created
  /// 0: the nonce generation function failed, or the secret key was invalid.
  /// Args:    ctx:       pointer to a context object (not secp256k1_context_static).
  /// Out:     sig:       pointer to an array where the signature will be placed.
  /// In:      msghash32: the 32-byte message hash being signed.
  /// seckey:    pointer to a 32-byte secret key.
  /// noncefp:   pointer to a nonce generation function. If NULL,
  /// secp256k1_nonce_function_default is used.
  /// ndata:     pointer to arbitrary data used by the nonce generation function
  /// (can be NULL). If it is non-NULL and
  /// secp256k1_nonce_function_default is used, then ndata must be a
  /// pointer to 32-bytes of additional data.
  ///
  /// The created signature is always in lower-S form. See
  /// secp256k1_ecdsa_signature_normalize for more details.
  int secp256k1_ecdsa_sign(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> msghash32,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    secp256k1_nonce_function noncefp,
    ffi.Pointer<ffi.Void> ndata,
  ) {
    return _secp256k1_ecdsa_sign(
      ctx,
      sig,
      msghash32,
      seckey,
      noncefp,
      ndata,
    );
  }

  late final _secp256k1_ecdsa_signPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              secp256k1_nonce_function,
              ffi.Pointer<ffi.Void>)>>('secp256k1_ecdsa_sign');
  late final _secp256k1_ecdsa_sign = _secp256k1_ecdsa_signPtr.asFunction<
      int Function(
          ffi.Pointer<secp256k1_context>,
          ffi.Pointer<secp256k1_ecdsa_signature>,
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<ffi.UnsignedChar>,
          secp256k1_nonce_function,
          ffi.Pointer<ffi.Void>)>();

  /// Verify an elliptic curve secret key.
  ///
  /// A secret key is valid if it is not 0 and less than the secp256k1 curve order
  /// when interpreted as an integer (most significant byte first). The
  /// probability of choosing a 32-byte string uniformly at random which is an
  /// invalid secret key is negligible. However, if it does happen it should
  /// be assumed that the randomness source is severely broken and there should
  /// be no retry.
  ///
  /// Returns: 1: secret key is valid
  /// 0: secret key is invalid
  /// Args:    ctx: pointer to a context object.
  /// In:      seckey: pointer to a 32-byte secret key.
  int secp256k1_ec_seckey_verify(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seckey,
  ) {
    return _secp256k1_ec_seckey_verify(
      ctx,
      seckey,
    );
  }

  late final _secp256k1_ec_seckey_verifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_seckey_verify');
  late final _secp256k1_ec_seckey_verify =
      _secp256k1_ec_seckey_verifyPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Compute the public key for a secret key.
  ///
  /// Returns: 1: secret was valid, public key stores.
  /// 0: secret was invalid, try again.
  /// Args:    ctx:    pointer to a context object (not secp256k1_context_static).
  /// Out:     pubkey: pointer to the created public key.
  /// In:      seckey: pointer to a 32-byte secret key.
  int secp256k1_ec_pubkey_create(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<ffi.UnsignedChar> seckey,
  ) {
    return _secp256k1_ec_pubkey_create(
      ctx,
      pubkey,
      seckey,
    );
  }

  late final _secp256k1_ec_pubkey_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_pubkey_create');
  late final _secp256k1_ec_pubkey_create =
      _secp256k1_ec_pubkey_createPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Negates a secret key in place.
  ///
  /// Returns: 0 if the given secret key is invalid according to
  /// secp256k1_ec_seckey_verify. 1 otherwise
  /// Args:   ctx:    pointer to a context object
  /// In/Out: seckey: pointer to the 32-byte secret key to be negated. If the
  /// secret key is invalid according to
  /// secp256k1_ec_seckey_verify, this function returns 0 and
  /// seckey will be set to some unspecified value.
  int secp256k1_ec_seckey_negate(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seckey,
  ) {
    return _secp256k1_ec_seckey_negate(
      ctx,
      seckey,
    );
  }

  late final _secp256k1_ec_seckey_negatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_seckey_negate');
  late final _secp256k1_ec_seckey_negate =
      _secp256k1_ec_seckey_negatePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Negates a public key in place.
  ///
  /// Returns: 1 always
  /// Args:   ctx:        pointer to a context object
  /// In/Out: pubkey:     pointer to the public key to be negated.
  int secp256k1_ec_pubkey_negate(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
  ) {
    return _secp256k1_ec_pubkey_negate(
      ctx,
      pubkey,
    );
  }

  late final _secp256k1_ec_pubkey_negatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>)>>('secp256k1_ec_pubkey_negate');
  late final _secp256k1_ec_pubkey_negate =
      _secp256k1_ec_pubkey_negatePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>, ffi.Pointer<secp256k1_pubkey>)>();

  /// Tweak a secret key by adding tweak to it.
  ///
  /// Returns: 0 if the arguments are invalid or the resulting secret key would be
  /// invalid (only when the tweak is the negation of the secret key). 1
  /// otherwise.
  /// Args:    ctx:   pointer to a context object.
  /// In/Out: seckey: pointer to a 32-byte secret key. If the secret key is
  /// invalid according to secp256k1_ec_seckey_verify, this
  /// function returns 0. seckey will be set to some unspecified
  /// value if this function returns 0.
  /// In:    tweak32: pointer to a 32-byte tweak, which must be valid according to
  /// secp256k1_ec_seckey_verify or 32 zero bytes. For uniformly
  /// random 32-byte tweaks, the chance of being invalid is
  /// negligible (around 1 in 2^128).
  int secp256k1_ec_seckey_tweak_add(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_ec_seckey_tweak_add(
      ctx,
      seckey,
      tweak32,
    );
  }

  late final _secp256k1_ec_seckey_tweak_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_seckey_tweak_add');
  late final _secp256k1_ec_seckey_tweak_add =
      _secp256k1_ec_seckey_tweak_addPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Tweak a public key by adding tweak times the generator to it.
  ///
  /// Returns: 0 if the arguments are invalid or the resulting public key would be
  /// invalid (only when the tweak is the negation of the corresponding
  /// secret key). 1 otherwise.
  /// Args:    ctx:   pointer to a context object.
  /// In/Out: pubkey: pointer to a public key object. pubkey will be set to an
  /// invalid value if this function returns 0.
  /// In:    tweak32: pointer to a 32-byte tweak, which must be valid according to
  /// secp256k1_ec_seckey_verify or 32 zero bytes. For uniformly
  /// random 32-byte tweaks, the chance of being invalid is
  /// negligible (around 1 in 2^128).
  int secp256k1_ec_pubkey_tweak_add(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_ec_pubkey_tweak_add(
      ctx,
      pubkey,
      tweak32,
    );
  }

  late final _secp256k1_ec_pubkey_tweak_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_pubkey_tweak_add');
  late final _secp256k1_ec_pubkey_tweak_add =
      _secp256k1_ec_pubkey_tweak_addPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Tweak a secret key by multiplying it by a tweak.
  ///
  /// Returns: 0 if the arguments are invalid. 1 otherwise.
  /// Args:   ctx:    pointer to a context object.
  /// In/Out: seckey: pointer to a 32-byte secret key. If the secret key is
  /// invalid according to secp256k1_ec_seckey_verify, this
  /// function returns 0. seckey will be set to some unspecified
  /// value if this function returns 0.
  /// In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to
  /// secp256k1_ec_seckey_verify, this function returns 0. For
  /// uniformly random 32-byte arrays the chance of being invalid
  /// is negligible (around 1 in 2^128).
  int secp256k1_ec_seckey_tweak_mul(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_ec_seckey_tweak_mul(
      ctx,
      seckey,
      tweak32,
    );
  }

  late final _secp256k1_ec_seckey_tweak_mulPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_seckey_tweak_mul');
  late final _secp256k1_ec_seckey_tweak_mul =
      _secp256k1_ec_seckey_tweak_mulPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Tweak a public key by multiplying it by a tweak value.
  ///
  /// Returns: 0 if the arguments are invalid. 1 otherwise.
  /// Args:    ctx:   pointer to a context object.
  /// In/Out: pubkey: pointer to a public key object. pubkey will be set to an
  /// invalid value if this function returns 0.
  /// In:    tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to
  /// secp256k1_ec_seckey_verify, this function returns 0. For
  /// uniformly random 32-byte arrays the chance of being invalid
  /// is negligible (around 1 in 2^128).
  int secp256k1_ec_pubkey_tweak_mul(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_ec_pubkey_tweak_mul(
      ctx,
      pubkey,
      tweak32,
    );
  }

  late final _secp256k1_ec_pubkey_tweak_mulPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ec_pubkey_tweak_mul');
  late final _secp256k1_ec_pubkey_tweak_mul =
      _secp256k1_ec_pubkey_tweak_mulPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Randomizes the context to provide enhanced protection against side-channel leakage.
  ///
  /// Returns: 1: randomization successful
  /// 0: error
  /// Args:    ctx:       pointer to a context object (not secp256k1_context_static).
  /// In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state).
  ///
  /// While secp256k1 code is written and tested to be constant-time no matter what
  /// secret values are, it is possible that a compiler may output code which is not,
  /// and also that the CPU may not emit the same radio frequencies or draw the same
  /// amount of power for all values. Randomization of the context shields against
  /// side-channel observations which aim to exploit secret-dependent behaviour in
  /// certain computations which involve secret keys.
  ///
  /// It is highly recommended to call this function on contexts returned from
  /// secp256k1_context_create or secp256k1_context_clone (or from the corresponding
  /// functions in secp256k1_preallocated.h) before using these contexts to call API
  /// functions that perform computations involving secret keys, e.g., signing and
  /// public key generation. It is possible to call this function more than once on
  /// the same context, and doing so before every few computations involving secret
  /// keys is recommended as a defense-in-depth measure. Randomization of the static
  /// context secp256k1_context_static is not supported.
  ///
  /// Currently, the random seed is mainly used for blinding multiplications of a
  /// secret scalar with the elliptic curve base point. Multiplications of this
  /// kind are performed by exactly those API functions which are documented to
  /// require a context that is not secp256k1_context_static. As a rule of thumb,
  /// these are all functions which take a secret key (or a keypair) as an input.
  /// A notable exception to that rule is the ECDH module, which relies on a different
  /// kind of elliptic curve point multiplication and thus does not benefit from
  /// enhanced protection against side-channel leakage currently.
  int secp256k1_context_randomize(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seed32,
  ) {
    return _secp256k1_context_randomize(
      ctx,
      seed32,
    );
  }

  late final _secp256k1_context_randomizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_context_randomize');
  late final _secp256k1_context_randomize =
      _secp256k1_context_randomizePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Add a number of public keys together.
  ///
  /// Returns: 1: the sum of the public keys is valid.
  /// 0: the sum of the public keys is not valid.
  /// Args:   ctx:        pointer to a context object.
  /// Out:    out:        pointer to a public key object for placing the resulting public key.
  /// In:     ins:        pointer to array of pointers to public keys.
  /// n:          the number of public keys to add together (must be at least 1).
  int secp256k1_ec_pubkey_combine(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> out,
    ffi.Pointer<ffi.Pointer<secp256k1_pubkey>> ins,
    int n,
  ) {
    return _secp256k1_ec_pubkey_combine(
      ctx,
      out,
      ins,
      n,
    );
  }

  late final _secp256k1_ec_pubkey_combinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.Pointer<secp256k1_pubkey>>,
              ffi.Size)>>('secp256k1_ec_pubkey_combine');
  late final _secp256k1_ec_pubkey_combine =
      _secp256k1_ec_pubkey_combinePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.Pointer<secp256k1_pubkey>>,
              int)>();

  /// Compute a tagged hash as defined in BIP-340.
  ///
  /// This is useful for creating a message hash and achieving domain separation
  /// through an application-specific tag. This function returns
  /// SHA256(SHA256(tag)||SHA256(tag)||msg). Therefore, tagged hash
  /// implementations optimized for a specific tag can precompute the SHA256 state
  /// after hashing the tag hashes.
  ///
  /// Returns: 1 always.
  /// Args:    ctx: pointer to a context object
  /// Out:  hash32: pointer to a 32-byte array to store the resulting hash
  /// In:      tag: pointer to an array containing the tag
  /// taglen: length of the tag array
  /// msg: pointer to an array containing the message
  /// msglen: length of the message array
  int secp256k1_tagged_sha256(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> hash32,
    ffi.Pointer<ffi.UnsignedChar> tag,
    int taglen,
    ffi.Pointer<ffi.UnsignedChar> msg,
    int msglen,
  ) {
    return _secp256k1_tagged_sha256(
      ctx,
      hash32,
      tag,
      taglen,
      msg,
      msglen,
    );
  }

  late final _secp256k1_tagged_sha256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('secp256k1_tagged_sha256');
  late final _secp256k1_tagged_sha256 = _secp256k1_tagged_sha256Ptr.asFunction<
      int Function(
          ffi.Pointer<secp256k1_context>,
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int)>();

  /// Parse a compact ECDSA signature (64 bytes + recovery id).
  ///
  /// Returns: 1 when the signature could be parsed, 0 otherwise
  /// Args: ctx:     pointer to a context object
  /// Out:  sig:     pointer to a signature object
  /// In:   input64: pointer to a 64-byte compact signature
  /// recid:   the recovery id (0, 1, 2 or 3)
  int secp256k1_ecdsa_recoverable_signature_parse_compact(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_recoverable_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> input64,
    int recid,
  ) {
    return _secp256k1_ecdsa_recoverable_signature_parse_compact(
      ctx,
      sig,
      input64,
      recid,
    );
  }

  late final _secp256k1_ecdsa_recoverable_signature_parse_compactPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int)>>('secp256k1_ecdsa_recoverable_signature_parse_compact');
  late final _secp256k1_ecdsa_recoverable_signature_parse_compact =
      _secp256k1_ecdsa_recoverable_signature_parse_compactPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              int)>();

  /// Convert a recoverable signature into a normal signature.
  ///
  /// Returns: 1
  /// Args: ctx:    pointer to a context object.
  /// Out:  sig:    pointer to a normal signature.
  /// In:   sigin:  pointer to a recoverable signature.
  int secp256k1_ecdsa_recoverable_signature_convert(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_signature> sig,
    ffi.Pointer<secp256k1_ecdsa_recoverable_signature> sigin,
  ) {
    return _secp256k1_ecdsa_recoverable_signature_convert(
      ctx,
      sig,
      sigin,
    );
  }

  late final _secp256k1_ecdsa_recoverable_signature_convertPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_ecdsa_signature>,
                  ffi.Pointer<secp256k1_ecdsa_recoverable_signature>)>>(
      'secp256k1_ecdsa_recoverable_signature_convert');
  late final _secp256k1_ecdsa_recoverable_signature_convert =
      _secp256k1_ecdsa_recoverable_signature_convertPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_signature>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>)>();

  /// Serialize an ECDSA signature in compact format (64 bytes + recovery id).
  ///
  /// Returns: 1
  /// Args: ctx:      pointer to a context object.
  /// Out:  output64: pointer to a 64-byte array of the compact signature.
  /// recid:    pointer to an integer to hold the recovery id.
  /// In:   sig:      pointer to an initialized signature object.
  int secp256k1_ecdsa_recoverable_signature_serialize_compact(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> output64,
    ffi.Pointer<ffi.Int> recid,
    ffi.Pointer<secp256k1_ecdsa_recoverable_signature> sig,
  ) {
    return _secp256k1_ecdsa_recoverable_signature_serialize_compact(
      ctx,
      output64,
      recid,
      sig,
    );
  }

  late final _secp256k1_ecdsa_recoverable_signature_serialize_compactPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<secp256k1_context>,
                      ffi.Pointer<ffi.UnsignedChar>,
                      ffi.Pointer<ffi.Int>,
                      ffi.Pointer<secp256k1_ecdsa_recoverable_signature>)>>(
          'secp256k1_ecdsa_recoverable_signature_serialize_compact');
  late final _secp256k1_ecdsa_recoverable_signature_serialize_compact =
      _secp256k1_ecdsa_recoverable_signature_serialize_compactPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>)>();

  /// Create a recoverable ECDSA signature.
  ///
  /// Returns: 1: signature created
  /// 0: the nonce generation function failed, or the secret key was invalid.
  /// Args:    ctx:       pointer to a context object (not secp256k1_context_static).
  /// Out:     sig:       pointer to an array where the signature will be placed.
  /// In:      msghash32: the 32-byte message hash being signed.
  /// seckey:    pointer to a 32-byte secret key.
  /// noncefp:   pointer to a nonce generation function. If NULL,
  /// secp256k1_nonce_function_default is used.
  /// ndata:     pointer to arbitrary data used by the nonce generation function
  /// (can be NULL for secp256k1_nonce_function_default).
  int secp256k1_ecdsa_sign_recoverable(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_ecdsa_recoverable_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> msghash32,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    secp256k1_nonce_function noncefp,
    ffi.Pointer<ffi.Void> ndata,
  ) {
    return _secp256k1_ecdsa_sign_recoverable(
      ctx,
      sig,
      msghash32,
      seckey,
      noncefp,
      ndata,
    );
  }

  late final _secp256k1_ecdsa_sign_recoverablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              secp256k1_nonce_function,
              ffi.Pointer<ffi.Void>)>>('secp256k1_ecdsa_sign_recoverable');
  late final _secp256k1_ecdsa_sign_recoverable =
      _secp256k1_ecdsa_sign_recoverablePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              secp256k1_nonce_function,
              ffi.Pointer<ffi.Void>)>();

  /// Recover an ECDSA public key from a signature.
  ///
  /// Returns: 1: public key successfully recovered (which guarantees a correct signature).
  /// 0: otherwise.
  /// Args:    ctx:       pointer to a context object.
  /// Out:     pubkey:    pointer to the recovered public key.
  /// In:      sig:       pointer to initialized signature that supports pubkey recovery.
  /// msghash32: the 32-byte message hash assumed to be signed.
  int secp256k1_ecdsa_recover(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<secp256k1_ecdsa_recoverable_signature> sig,
    ffi.Pointer<ffi.UnsignedChar> msghash32,
  ) {
    return _secp256k1_ecdsa_recover(
      ctx,
      pubkey,
      sig,
      msghash32,
    );
  }

  late final _secp256k1_ecdsa_recoverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<secp256k1_ecdsa_recoverable_signature>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_ecdsa_recover');
  late final _secp256k1_ecdsa_recover = _secp256k1_ecdsa_recoverPtr.asFunction<
      int Function(
          ffi.Pointer<secp256k1_context>,
          ffi.Pointer<secp256k1_pubkey>,
          ffi.Pointer<secp256k1_ecdsa_recoverable_signature>,
          ffi.Pointer<ffi.UnsignedChar>)>();

  /// Parse a 32-byte sequence into a xonly_pubkey object.
  ///
  /// Returns: 1 if the public key was fully valid.
  /// 0 if the public key could not be parsed or is invalid.
  ///
  /// Args:   ctx: pointer to a context object.
  /// Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a
  /// parsed version of input. If not, it's set to an invalid value.
  /// In: input32: pointer to a serialized xonly_pubkey.
  int secp256k1_xonly_pubkey_parse(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_xonly_pubkey> pubkey,
    ffi.Pointer<ffi.UnsignedChar> input32,
  ) {
    return _secp256k1_xonly_pubkey_parse(
      ctx,
      pubkey,
      input32,
    );
  }

  late final _secp256k1_xonly_pubkey_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_xonly_pubkey_parse');
  late final _secp256k1_xonly_pubkey_parse =
      _secp256k1_xonly_pubkey_parsePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Serialize an xonly_pubkey object into a 32-byte sequence.
  ///
  /// Returns: 1 always.
  ///
  /// Args:     ctx: pointer to a context object.
  /// Out: output32: pointer to a 32-byte array to place the serialized key in.
  /// In:    pubkey: pointer to a secp256k1_xonly_pubkey containing an initialized public key.
  int secp256k1_xonly_pubkey_serialize(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> output32,
    ffi.Pointer<secp256k1_xonly_pubkey> pubkey,
  ) {
    return _secp256k1_xonly_pubkey_serialize(
      ctx,
      output32,
      pubkey,
    );
  }

  late final _secp256k1_xonly_pubkey_serializePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<secp256k1_xonly_pubkey>)>>(
      'secp256k1_xonly_pubkey_serialize');
  late final _secp256k1_xonly_pubkey_serialize =
      _secp256k1_xonly_pubkey_serializePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_xonly_pubkey>)>();

  /// Compare two x-only public keys using lexicographic order
  ///
  /// Returns: <0 if the first public key is less than the second
  /// >0 if the first public key is greater than the second
  /// 0 if the two public keys are equal
  /// Args: ctx:      pointer to a context object.
  /// In:   pubkey1:  first public key to compare
  /// pubkey2:  second public key to compare
  int secp256k1_xonly_pubkey_cmp(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_xonly_pubkey> pk1,
    ffi.Pointer<secp256k1_xonly_pubkey> pk2,
  ) {
    return _secp256k1_xonly_pubkey_cmp(
      ctx,
      pk1,
      pk2,
    );
  }

  late final _secp256k1_xonly_pubkey_cmpPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_xonly_pubkey>,
                  ffi.Pointer<secp256k1_xonly_pubkey>)>>(
      'secp256k1_xonly_pubkey_cmp');
  late final _secp256k1_xonly_pubkey_cmp =
      _secp256k1_xonly_pubkey_cmpPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<secp256k1_xonly_pubkey>)>();

  /// Converts a secp256k1_pubkey into a secp256k1_xonly_pubkey.
  ///
  /// Returns: 1 always.
  ///
  /// Args:         ctx: pointer to a context object.
  /// Out: xonly_pubkey: pointer to an x-only public key object for placing the converted public key.
  /// pk_parity: Ignored if NULL. Otherwise, pointer to an integer that
  /// will be set to 1 if the point encoded by xonly_pubkey is
  /// the negation of the pubkey and set to 0 otherwise.
  /// In:        pubkey: pointer to a public key that is converted.
  int secp256k1_xonly_pubkey_from_pubkey(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_xonly_pubkey> xonly_pubkey,
    ffi.Pointer<ffi.Int> pk_parity,
    ffi.Pointer<secp256k1_pubkey> pubkey,
  ) {
    return _secp256k1_xonly_pubkey_from_pubkey(
      ctx,
      xonly_pubkey,
      pk_parity,
      pubkey,
    );
  }

  late final _secp256k1_xonly_pubkey_from_pubkeyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_xonly_pubkey>,
                  ffi.Pointer<ffi.Int>,
                  ffi.Pointer<secp256k1_pubkey>)>>(
      'secp256k1_xonly_pubkey_from_pubkey');
  late final _secp256k1_xonly_pubkey_from_pubkey =
      _secp256k1_xonly_pubkey_from_pubkeyPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<secp256k1_pubkey>)>();

  /// Tweak an x-only public key by adding the generator multiplied with tweak32
  /// to it.
  ///
  /// Note that the resulting point can not in general be represented by an x-only
  /// pubkey because it may have an odd Y coordinate. Instead, the output_pubkey
  /// is a normal secp256k1_pubkey.
  ///
  /// Returns: 0 if the arguments are invalid or the resulting public key would be
  /// invalid (only when the tweak is the negation of the corresponding
  /// secret key). 1 otherwise.
  ///
  /// Args:           ctx: pointer to a context object.
  /// Out:  output_pubkey: pointer to a public key to store the result. Will be set
  /// to an invalid value if this function returns 0.
  /// In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to.
  /// tweak32: pointer to a 32-byte tweak, which must be valid
  /// according to secp256k1_ec_seckey_verify or 32 zero
  /// bytes. For uniformly random 32-byte tweaks, the chance of
  /// being invalid is negligible (around 1 in 2^128).
  int secp256k1_xonly_pubkey_tweak_add(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> output_pubkey,
    ffi.Pointer<secp256k1_xonly_pubkey> internal_pubkey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_xonly_pubkey_tweak_add(
      ctx,
      output_pubkey,
      internal_pubkey,
      tweak32,
    );
  }

  late final _secp256k1_xonly_pubkey_tweak_addPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_pubkey>,
                  ffi.Pointer<secp256k1_xonly_pubkey>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_xonly_pubkey_tweak_add');
  late final _secp256k1_xonly_pubkey_tweak_add =
      _secp256k1_xonly_pubkey_tweak_addPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Checks that a tweaked pubkey is the result of calling
  /// secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.
  ///
  /// The tweaked pubkey is represented by its 32-byte x-only serialization and
  /// its pk_parity, which can both be obtained by converting the result of
  /// tweak_add to a secp256k1_xonly_pubkey.
  ///
  /// Note that this alone does _not_ verify that the tweaked pubkey is a
  /// commitment. If the tweak is not chosen in a specific way, the tweaked pubkey
  /// can easily be the result of a different internal_pubkey and tweak.
  ///
  /// Returns: 0 if the arguments are invalid or the tweaked pubkey is not the
  /// result of tweaking the internal_pubkey with tweak32. 1 otherwise.
  /// Args:            ctx: pointer to a context object.
  /// In: tweaked_pubkey32: pointer to a serialized xonly_pubkey.
  /// tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization
  /// is passed in as tweaked_pubkey32). This must match the
  /// pk_parity value that is returned when calling
  /// secp256k1_xonly_pubkey with the tweaked pubkey, or
  /// this function will fail.
  /// internal_pubkey: pointer to an x-only public key object to apply the tweak to.
  /// tweak32: pointer to a 32-byte tweak.
  int secp256k1_xonly_pubkey_tweak_add_check(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> tweaked_pubkey32,
    int tweaked_pk_parity,
    ffi.Pointer<secp256k1_xonly_pubkey> internal_pubkey,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_xonly_pubkey_tweak_add_check(
      ctx,
      tweaked_pubkey32,
      tweaked_pk_parity,
      internal_pubkey,
      tweak32,
    );
  }

  late final _secp256k1_xonly_pubkey_tweak_add_checkPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Int,
                  ffi.Pointer<secp256k1_xonly_pubkey>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_xonly_pubkey_tweak_add_check');
  late final _secp256k1_xonly_pubkey_tweak_add_check =
      _secp256k1_xonly_pubkey_tweak_add_checkPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Compute the keypair for a valid secret key.
  ///
  /// See the documentation of `secp256k1_ec_seckey_verify` for more information
  /// about the validity of secret keys.
  ///
  /// Returns: 1: secret key is valid
  /// 0: secret key is invalid
  /// Args:    ctx: pointer to a context object (not secp256k1_context_static).
  /// Out: keypair: pointer to the created keypair.
  /// In:   seckey: pointer to a 32-byte secret key.
  int secp256k1_keypair_create(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_keypair> keypair,
    ffi.Pointer<ffi.UnsignedChar> seckey,
  ) {
    return _secp256k1_keypair_create(
      ctx,
      keypair,
      seckey,
    );
  }

  late final _secp256k1_keypair_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_keypair_create');
  late final _secp256k1_keypair_create =
      _secp256k1_keypair_createPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_keypair>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Get the secret key from a keypair.
  ///
  /// Returns: 1 always.
  /// Args:   ctx: pointer to a context object.
  /// Out: seckey: pointer to a 32-byte buffer for the secret key.
  /// In: keypair: pointer to a keypair.
  int secp256k1_keypair_sec(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    ffi.Pointer<secp256k1_keypair> keypair,
  ) {
    return _secp256k1_keypair_sec(
      ctx,
      seckey,
      keypair,
    );
  }

  late final _secp256k1_keypair_secPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_keypair>)>>('secp256k1_keypair_sec');
  late final _secp256k1_keypair_sec = _secp256k1_keypair_secPtr.asFunction<
      int Function(ffi.Pointer<secp256k1_context>,
          ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<secp256k1_keypair>)>();

  /// Get the public key from a keypair.
  ///
  /// Returns: 1 always.
  /// Args:   ctx: pointer to a context object.
  /// Out: pubkey: pointer to a pubkey object, set to the keypair public key.
  /// In: keypair: pointer to a keypair.
  int secp256k1_keypair_pub(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<secp256k1_keypair> keypair,
  ) {
    return _secp256k1_keypair_pub(
      ctx,
      pubkey,
      keypair,
    );
  }

  late final _secp256k1_keypair_pubPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<secp256k1_keypair>)>>('secp256k1_keypair_pub');
  late final _secp256k1_keypair_pub = _secp256k1_keypair_pubPtr.asFunction<
      int Function(ffi.Pointer<secp256k1_context>,
          ffi.Pointer<secp256k1_pubkey>, ffi.Pointer<secp256k1_keypair>)>();

  /// Get the x-only public key from a keypair.
  ///
  /// This is the same as calling secp256k1_keypair_pub and then
  /// secp256k1_xonly_pubkey_from_pubkey.
  ///
  /// Returns: 1 always.
  /// Args:   ctx: pointer to a context object.
  /// Out: pubkey: pointer to an xonly_pubkey object, set to the keypair
  /// public key after converting it to an xonly_pubkey.
  /// pk_parity: Ignored if NULL. Otherwise, pointer to an integer that will be set to the
  /// pk_parity argument of secp256k1_xonly_pubkey_from_pubkey.
  /// In: keypair: pointer to a keypair.
  int secp256k1_keypair_xonly_pub(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_xonly_pubkey> pubkey,
    ffi.Pointer<ffi.Int> pk_parity,
    ffi.Pointer<secp256k1_keypair> keypair,
  ) {
    return _secp256k1_keypair_xonly_pub(
      ctx,
      pubkey,
      pk_parity,
      keypair,
    );
  }

  late final _secp256k1_keypair_xonly_pubPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<secp256k1_keypair>)>>('secp256k1_keypair_xonly_pub');
  late final _secp256k1_keypair_xonly_pub =
      _secp256k1_keypair_xonly_pubPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<secp256k1_keypair>)>();

  /// Tweak a keypair by adding tweak32 to the secret key and updating the public
  /// key accordingly.
  ///
  /// Calling this function and then secp256k1_keypair_pub results in the same
  /// public key as calling secp256k1_keypair_xonly_pub and then
  /// secp256k1_xonly_pubkey_tweak_add.
  ///
  /// Returns: 0 if the arguments are invalid or the resulting keypair would be
  /// invalid (only when the tweak is the negation of the keypair's
  /// secret key). 1 otherwise.
  ///
  /// Args:       ctx: pointer to a context object.
  /// In/Out: keypair: pointer to a keypair to apply the tweak to. Will be set to
  /// an invalid value if this function returns 0.
  /// In:     tweak32: pointer to a 32-byte tweak, which must be valid according to
  /// secp256k1_ec_seckey_verify or 32 zero bytes. For uniformly
  /// random 32-byte tweaks, the chance of being invalid is
  /// negligible (around 1 in 2^128).
  int secp256k1_keypair_xonly_tweak_add(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_keypair> keypair,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_keypair_xonly_tweak_add(
      ctx,
      keypair,
      tweak32,
    );
  }

  late final _secp256k1_keypair_xonly_tweak_addPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_keypair>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_keypair_xonly_tweak_add');
  late final _secp256k1_keypair_xonly_tweak_add =
      _secp256k1_keypair_xonly_tweak_addPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_keypair>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// An implementation of the nonce generation function as defined in Bitcoin
  /// Improvement Proposal 340 "Schnorr Signatures for secp256k1"
  /// (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).
  ///
  /// If a data pointer is passed, it is assumed to be a pointer to 32 bytes of
  /// auxiliary random data as defined in BIP-340. If the data pointer is NULL,
  /// the nonce derivation procedure follows BIP-340 by setting the auxiliary
  /// random data to zero. The algo argument must be non-NULL, otherwise the
  /// function will fail and return 0. The hash will be tagged with algo.
  /// Therefore, to create BIP-340 compliant signatures, algo must be set to
  /// "BIP0340/nonce" and algolen to 13.
  late final ffi.Pointer<secp256k1_nonce_function_hardened>
      _secp256k1_nonce_function_bip340 =
      _lookup<secp256k1_nonce_function_hardened>(
          'secp256k1_nonce_function_bip340');

  secp256k1_nonce_function_hardened get secp256k1_nonce_function_bip340 =>
      _secp256k1_nonce_function_bip340.value;

  /// Create a Schnorr signature.
  ///
  /// Does _not_ strictly follow BIP-340 because it does not verify the resulting
  /// signature. Instead, you can manually use secp256k1_schnorrsig_verify and
  /// abort if it fails.
  ///
  /// This function only signs 32-byte messages. If you have messages of a
  /// different size (or the same size but without a context-specific tag
  /// prefix), it is recommended to create a 32-byte message hash with
  /// secp256k1_tagged_sha256 and then sign the hash. Tagged hashing allows
  /// providing an context-specific tag for domain separation. This prevents
  /// signatures from being valid in multiple contexts by accident.
  ///
  /// Returns 1 on success, 0 on failure.
  /// Args:    ctx: pointer to a context object (not secp256k1_context_static).
  /// Out:   sig64: pointer to a 64-byte array to store the serialized signature.
  /// In:    msg32: the 32-byte message being signed.
  /// keypair: pointer to an initialized keypair.
  /// aux_rand32: 32 bytes of fresh randomness. While recommended to provide
  /// this, it is only supplemental to security and can be NULL. A
  /// NULL argument is treated the same as an all-zero one. See
  /// BIP-340 "Default Signing" for a full explanation of this
  /// argument and for guidance if randomness is expensive.
  int secp256k1_schnorrsig_sign32(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> sig64,
    ffi.Pointer<ffi.UnsignedChar> msg32,
    ffi.Pointer<secp256k1_keypair> keypair,
    ffi.Pointer<ffi.UnsignedChar> aux_rand32,
  ) {
    return _secp256k1_schnorrsig_sign32(
      ctx,
      sig64,
      msg32,
      keypair,
      aux_rand32,
    );
  }

  late final _secp256k1_schnorrsig_sign32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_schnorrsig_sign32');
  late final _secp256k1_schnorrsig_sign32 =
      _secp256k1_schnorrsig_sign32Ptr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Same as secp256k1_schnorrsig_sign32, but DEPRECATED. Will be removed in
  /// future versions.
  int secp256k1_schnorrsig_sign(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> sig64,
    ffi.Pointer<ffi.UnsignedChar> msg32,
    ffi.Pointer<secp256k1_keypair> keypair,
    ffi.Pointer<ffi.UnsignedChar> aux_rand32,
  ) {
    return _secp256k1_schnorrsig_sign(
      ctx,
      sig64,
      msg32,
      keypair,
      aux_rand32,
    );
  }

  late final _secp256k1_schnorrsig_signPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_schnorrsig_sign');
  late final _secp256k1_schnorrsig_sign =
      _secp256k1_schnorrsig_signPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Create a Schnorr signature with a more flexible API.
  ///
  /// Same arguments as secp256k1_schnorrsig_sign except that it allows signing
  /// variable length messages and accepts a pointer to an extraparams object that
  /// allows customizing signing by passing additional arguments.
  ///
  /// Equivalent to secp256k1_schnorrsig_sign32(..., aux_rand32) if msglen is 32
  /// and extraparams is initialized as follows:
  /// ```
  /// secp256k1_schnorrsig_extraparams extraparams = SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT;
  /// extraparams.ndata = (unsigned char*)aux_rand32;
  /// ```
  ///
  /// Returns 1 on success, 0 on failure.
  /// Args:   ctx: pointer to a context object (not secp256k1_context_static).
  /// Out:  sig64: pointer to a 64-byte array to store the serialized signature.
  /// In:     msg: the message being signed. Can only be NULL if msglen is 0.
  /// msglen: length of the message.
  /// keypair: pointer to an initialized keypair.
  /// extraparams: pointer to an extraparams object (can be NULL).
  int secp256k1_schnorrsig_sign_custom(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> sig64,
    ffi.Pointer<ffi.UnsignedChar> msg,
    int msglen,
    ffi.Pointer<secp256k1_keypair> keypair,
    ffi.Pointer<secp256k1_schnorrsig_extraparams> extraparams,
  ) {
    return _secp256k1_schnorrsig_sign_custom(
      ctx,
      sig64,
      msg,
      msglen,
      keypair,
      extraparams,
    );
  }

  late final _secp256k1_schnorrsig_sign_customPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Size,
                  ffi.Pointer<secp256k1_keypair>,
                  ffi.Pointer<secp256k1_schnorrsig_extraparams>)>>(
      'secp256k1_schnorrsig_sign_custom');
  late final _secp256k1_schnorrsig_sign_custom =
      _secp256k1_schnorrsig_sign_customPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<secp256k1_schnorrsig_extraparams>)>();

  /// Verify a Schnorr signature.
  ///
  /// Returns: 1: correct signature
  /// 0: incorrect signature
  /// Args:    ctx: pointer to a context object.
  /// In:    sig64: pointer to the 64-byte signature to verify.
  /// msg: the message being verified. Can only be NULL if msglen is 0.
  /// msglen: length of the message
  /// pubkey: pointer to an x-only public key to verify with
  int secp256k1_schnorrsig_verify(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> sig64,
    ffi.Pointer<ffi.UnsignedChar> msg,
    int msglen,
    ffi.Pointer<secp256k1_xonly_pubkey> pubkey,
  ) {
    return _secp256k1_schnorrsig_verify(
      ctx,
      sig64,
      msg,
      msglen,
      pubkey,
    );
  }

  late final _secp256k1_schnorrsig_verifyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Size,
                  ffi.Pointer<secp256k1_xonly_pubkey>)>>(
      'secp256k1_schnorrsig_verify');
  late final _secp256k1_schnorrsig_verify =
      _secp256k1_schnorrsig_verifyPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<secp256k1_xonly_pubkey>)>();

  /// An implementation of SHA256 hash function that applies to compressed public key.
  /// Populates the output parameter with 32 bytes.
  late final ffi.Pointer<secp256k1_ecdh_hash_function>
      _secp256k1_ecdh_hash_function_sha256 =
      _lookup<secp256k1_ecdh_hash_function>(
          'secp256k1_ecdh_hash_function_sha256');

  secp256k1_ecdh_hash_function get secp256k1_ecdh_hash_function_sha256 =>
      _secp256k1_ecdh_hash_function_sha256.value;

  /// A default ECDH hash function (currently equal to secp256k1_ecdh_hash_function_sha256).
  /// Populates the output parameter with 32 bytes.
  late final ffi.Pointer<secp256k1_ecdh_hash_function>
      _secp256k1_ecdh_hash_function_default =
      _lookup<secp256k1_ecdh_hash_function>(
          'secp256k1_ecdh_hash_function_default');

  secp256k1_ecdh_hash_function get secp256k1_ecdh_hash_function_default =>
      _secp256k1_ecdh_hash_function_default.value;

  /// Compute an EC Diffie-Hellman secret in constant time
  ///
  /// Returns: 1: exponentiation was successful
  /// 0: scalar was invalid (zero or overflow) or hashfp returned 0
  /// Args:    ctx:        pointer to a context object.
  /// Out:     output:     pointer to an array to be filled by hashfp.
  /// In:      pubkey:     pointer to a secp256k1_pubkey containing an initialized public key.
  /// seckey:     a 32-byte scalar with which to multiply the point.
  /// hashfp:     pointer to a hash function. If NULL,
  /// secp256k1_ecdh_hash_function_sha256 is used
  /// (in which case, 32 bytes will be written to output).
  /// data:       arbitrary data pointer that is passed through to hashfp
  /// (can be NULL for secp256k1_ecdh_hash_function_sha256).
  int secp256k1_ecdh(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> output,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    secp256k1_ecdh_hash_function hashfp,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _secp256k1_ecdh(
      ctx,
      output,
      pubkey,
      seckey,
      hashfp,
      data,
    );
  }

  late final _secp256k1_ecdhPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>,
              secp256k1_ecdh_hash_function,
              ffi.Pointer<ffi.Void>)>>('secp256k1_ecdh');
  late final _secp256k1_ecdh = _secp256k1_ecdhPtr.asFunction<
      int Function(
          ffi.Pointer<secp256k1_context>,
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<secp256k1_pubkey>,
          ffi.Pointer<ffi.UnsignedChar>,
          secp256k1_ecdh_hash_function,
          ffi.Pointer<ffi.Void>)>();

  /// Parse a signer's public nonce.
  ///
  /// Returns: 1 when the nonce could be parsed, 0 otherwise.
  /// Args:    ctx: pointer to a context object
  /// Out:   nonce: pointer to a nonce object
  /// In:     in66: pointer to the 66-byte nonce to be parsed
  int secp256k1_musig_pubnonce_parse(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_musig_pubnonce> nonce,
    ffi.Pointer<ffi.UnsignedChar> in66,
  ) {
    return _secp256k1_musig_pubnonce_parse(
      ctx,
      nonce,
      in66,
    );
  }

  late final _secp256k1_musig_pubnonce_parsePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_musig_pubnonce>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_musig_pubnonce_parse');
  late final _secp256k1_musig_pubnonce_parse =
      _secp256k1_musig_pubnonce_parsePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_musig_pubnonce>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Serialize a signer's public nonce
  ///
  /// Returns: 1 always
  /// Args:    ctx: pointer to a context object
  /// Out:   out66: pointer to a 66-byte array to store the serialized nonce
  /// In:    nonce: pointer to the nonce
  int secp256k1_musig_pubnonce_serialize(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> out66,
    ffi.Pointer<secp256k1_musig_pubnonce> nonce,
  ) {
    return _secp256k1_musig_pubnonce_serialize(
      ctx,
      out66,
      nonce,
    );
  }

  late final _secp256k1_musig_pubnonce_serializePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<secp256k1_musig_pubnonce>)>>(
      'secp256k1_musig_pubnonce_serialize');
  late final _secp256k1_musig_pubnonce_serialize =
      _secp256k1_musig_pubnonce_serializePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_musig_pubnonce>)>();

  /// Parse an aggregate public nonce.
  ///
  /// Returns: 1 when the nonce could be parsed, 0 otherwise.
  /// Args:    ctx: pointer to a context object
  /// Out:   nonce: pointer to a nonce object
  /// In:     in66: pointer to the 66-byte nonce to be parsed
  int secp256k1_musig_aggnonce_parse(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_musig_aggnonce> nonce,
    ffi.Pointer<ffi.UnsignedChar> in66,
  ) {
    return _secp256k1_musig_aggnonce_parse(
      ctx,
      nonce,
      in66,
    );
  }

  late final _secp256k1_musig_aggnonce_parsePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_musig_aggnonce>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_musig_aggnonce_parse');
  late final _secp256k1_musig_aggnonce_parse =
      _secp256k1_musig_aggnonce_parsePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_musig_aggnonce>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Serialize an aggregate public nonce
  ///
  /// Returns: 1 always
  /// Args:    ctx: pointer to a context object
  /// Out:   out66: pointer to a 66-byte array to store the serialized nonce
  /// In:    nonce: pointer to the nonce
  int secp256k1_musig_aggnonce_serialize(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> out66,
    ffi.Pointer<secp256k1_musig_aggnonce> nonce,
  ) {
    return _secp256k1_musig_aggnonce_serialize(
      ctx,
      out66,
      nonce,
    );
  }

  late final _secp256k1_musig_aggnonce_serializePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<secp256k1_musig_aggnonce>)>>(
      'secp256k1_musig_aggnonce_serialize');
  late final _secp256k1_musig_aggnonce_serialize =
      _secp256k1_musig_aggnonce_serializePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_musig_aggnonce>)>();

  /// Parse a MuSig partial signature.
  ///
  /// Returns: 1 when the signature could be parsed, 0 otherwise.
  /// Args:    ctx: pointer to a context object
  /// Out:     sig: pointer to a signature object
  /// In:     in32: pointer to the 32-byte signature to be parsed
  int secp256k1_musig_partial_sig_parse(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_musig_partial_sig> sig,
    ffi.Pointer<ffi.UnsignedChar> in32,
  ) {
    return _secp256k1_musig_partial_sig_parse(
      ctx,
      sig,
      in32,
    );
  }

  late final _secp256k1_musig_partial_sig_parsePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_musig_partial_sig>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_musig_partial_sig_parse');
  late final _secp256k1_musig_partial_sig_parse =
      _secp256k1_musig_partial_sig_parsePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_musig_partial_sig>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Serialize a MuSig partial signature
  ///
  /// Returns: 1 always
  /// Args:    ctx: pointer to a context object
  /// Out:   out32: pointer to a 32-byte array to store the serialized signature
  /// In:      sig: pointer to the signature
  int secp256k1_musig_partial_sig_serialize(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> out32,
    ffi.Pointer<secp256k1_musig_partial_sig> sig,
  ) {
    return _secp256k1_musig_partial_sig_serialize(
      ctx,
      out32,
      sig,
    );
  }

  late final _secp256k1_musig_partial_sig_serializePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<secp256k1_musig_partial_sig>)>>(
      'secp256k1_musig_partial_sig_serialize');
  late final _secp256k1_musig_partial_sig_serialize =
      _secp256k1_musig_partial_sig_serializePtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_musig_partial_sig>)>();

  /// Computes an aggregate public key and uses it to initialize a keyagg_cache
  ///
  /// Different orders of `pubkeys` result in different `agg_pk`s.
  ///
  /// Before aggregating, the pubkeys can be sorted with `secp256k1_ec_pubkey_sort`
  /// which ensures the same `agg_pk` result for the same multiset of pubkeys.
  /// This is useful to do before `pubkey_agg`, such that the order of pubkeys
  /// does not affect the aggregate public key.
  ///
  /// Returns: 0 if the arguments are invalid, 1 otherwise
  /// Args:        ctx: pointer to a context object
  /// Out:      agg_pk: the MuSig-aggregated x-only public key. If you do not need it,
  /// this arg can be NULL.
  /// keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that
  /// is required for signing (or observing the signing session
  /// and verifying partial signatures).
  /// In:     pubkeys: input array of pointers to public keys to aggregate. The order
  /// is important; a different order will result in a different
  /// aggregate public key.
  /// n_pubkeys: length of pubkeys array. Must be greater than 0.
  int secp256k1_musig_pubkey_agg(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_xonly_pubkey> agg_pk,
    ffi.Pointer<secp256k1_musig_keyagg_cache> keyagg_cache,
    ffi.Pointer<ffi.Pointer<secp256k1_pubkey>> pubkeys,
    int n_pubkeys,
  ) {
    return _secp256k1_musig_pubkey_agg(
      ctx,
      agg_pk,
      keyagg_cache,
      pubkeys,
      n_pubkeys,
    );
  }

  late final _secp256k1_musig_pubkey_aggPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<secp256k1_musig_keyagg_cache>,
              ffi.Pointer<ffi.Pointer<secp256k1_pubkey>>,
              ffi.Size)>>('secp256k1_musig_pubkey_agg');
  late final _secp256k1_musig_pubkey_agg =
      _secp256k1_musig_pubkey_aggPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_xonly_pubkey>,
              ffi.Pointer<secp256k1_musig_keyagg_cache>,
              ffi.Pointer<ffi.Pointer<secp256k1_pubkey>>,
              int)>();

  /// Obtain the aggregate public key from a keyagg_cache.
  ///
  /// This is only useful if you need the non-xonly public key, in particular for
  /// plain (non-xonly) tweaking or batch-verifying multiple key aggregations
  /// (not implemented).
  ///
  /// Returns: 0 if the arguments are invalid, 1 otherwise
  /// Args:        ctx: pointer to a context object
  /// Out:      agg_pk: the MuSig-aggregated public key.
  /// In: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by
  /// `musig_pubkey_agg`
  int secp256k1_musig_pubkey_get(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> agg_pk,
    ffi.Pointer<secp256k1_musig_keyagg_cache> keyagg_cache,
  ) {
    return _secp256k1_musig_pubkey_get(
      ctx,
      agg_pk,
      keyagg_cache,
    );
  }

  late final _secp256k1_musig_pubkey_getPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_pubkey>,
                  ffi.Pointer<secp256k1_musig_keyagg_cache>)>>(
      'secp256k1_musig_pubkey_get');
  late final _secp256k1_musig_pubkey_get =
      _secp256k1_musig_pubkey_getPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<secp256k1_musig_keyagg_cache>)>();

  /// Apply plain "EC" tweaking to a public key in a given keyagg_cache by adding
  /// the generator multiplied with `tweak32` to it. This is useful for deriving
  /// child keys from an aggregate public key via BIP 32 where `tweak32` is set to
  /// a hash as defined in BIP 32.
  ///
  /// Callers are responsible for deriving `tweak32` in a way that does not reduce
  /// the security of MuSig (for example, by following BIP 32).
  ///
  /// The tweaking method is the same as `secp256k1_ec_pubkey_tweak_add`. So after
  /// the following pseudocode buf and buf2 have identical contents (absent
  /// earlier failures).
  ///
  /// secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...)
  /// secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache)
  /// secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache)
  /// secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...)
  /// secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32)
  /// secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)
  ///
  /// This function is required if you want to _sign_ for a tweaked aggregate key.
  /// If you are only computing a public key but not intending to create a
  /// signature for it, use `secp256k1_ec_pubkey_tweak_add` instead.
  ///
  /// Returns: 0 if the arguments are invalid, 1 otherwise
  /// Args:            ctx: pointer to a context object
  /// Out:   output_pubkey: pointer to a public key to store the result. Will be set
  /// to an invalid value if this function returns 0. If you
  /// do not need it, this arg can be NULL.
  /// In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by
  /// `musig_pubkey_agg`
  /// In:          tweak32: pointer to a 32-byte tweak. The tweak is valid if it passes
  /// `secp256k1_ec_seckey_verify` and is not equal to the
  /// secret key corresponding to the public key represented
  /// by keyagg_cache or its negation. For uniformly random
  /// 32-byte arrays the chance of being invalid is
  /// negligible (around 1 in 2^128).
  int secp256k1_musig_pubkey_ec_tweak_add(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> output_pubkey,
    ffi.Pointer<secp256k1_musig_keyagg_cache> keyagg_cache,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_musig_pubkey_ec_tweak_add(
      ctx,
      output_pubkey,
      keyagg_cache,
      tweak32,
    );
  }

  late final _secp256k1_musig_pubkey_ec_tweak_addPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_pubkey>,
                  ffi.Pointer<secp256k1_musig_keyagg_cache>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_musig_pubkey_ec_tweak_add');
  late final _secp256k1_musig_pubkey_ec_tweak_add =
      _secp256k1_musig_pubkey_ec_tweak_addPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<secp256k1_musig_keyagg_cache>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Apply x-only tweaking to a public key in a given keyagg_cache by adding the
  /// generator multiplied with `tweak32` to it. This is useful for creating
  /// Taproot outputs where `tweak32` is set to a TapTweak hash as defined in BIP
  /// 341.
  ///
  /// Callers are responsible for deriving `tweak32` in a way that does not reduce
  /// the security of MuSig (for example, by following Taproot BIP 341).
  ///
  /// The tweaking method is the same as `secp256k1_xonly_pubkey_tweak_add`. So in
  /// the following pseudocode xonly_pubkey_tweak_add_check (absent earlier
  /// failures) returns 1.
  ///
  /// secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...)
  /// secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32)
  /// secp256k1_xonly_pubkey_serialize(..., buf, output_pk)
  /// secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)
  ///
  /// This function is required if you want to _sign_ for a tweaked aggregate key.
  /// If you are only computing a public key but not intending to create a
  /// signature for it, use `secp256k1_xonly_pubkey_tweak_add` instead.
  ///
  /// Returns: 0 if the arguments are invalid, 1 otherwise
  /// Args:            ctx: pointer to a context object
  /// Out:   output_pubkey: pointer to a public key to store the result. Will be set
  /// to an invalid value if this function returns 0. If you
  /// do not need it, this arg can be NULL.
  /// In/Out: keyagg_cache: pointer to a `musig_keyagg_cache` struct initialized by
  /// `musig_pubkey_agg`
  /// In:          tweak32: pointer to a 32-byte tweak. The tweak is valid if it passes
  /// `secp256k1_ec_seckey_verify` and is not equal to the
  /// secret key corresponding to the public key represented
  /// by keyagg_cache or its negation. For uniformly random
  /// 32-byte arrays the chance of being invalid is
  /// negligible (around 1 in 2^128).
  int secp256k1_musig_pubkey_xonly_tweak_add(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_pubkey> output_pubkey,
    ffi.Pointer<secp256k1_musig_keyagg_cache> keyagg_cache,
    ffi.Pointer<ffi.UnsignedChar> tweak32,
  ) {
    return _secp256k1_musig_pubkey_xonly_tweak_add(
      ctx,
      output_pubkey,
      keyagg_cache,
      tweak32,
    );
  }

  late final _secp256k1_musig_pubkey_xonly_tweak_addPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_pubkey>,
                  ffi.Pointer<secp256k1_musig_keyagg_cache>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_musig_pubkey_xonly_tweak_add');
  late final _secp256k1_musig_pubkey_xonly_tweak_add =
      _secp256k1_musig_pubkey_xonly_tweak_addPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<secp256k1_musig_keyagg_cache>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Starts a signing session by generating a nonce
  ///
  /// This function outputs a secret nonce that will be required for signing and a
  /// corresponding public nonce that is intended to be sent to other signers.
  ///
  /// MuSig differs from regular Schnorr signing in that implementers _must_ take
  /// special care to not reuse a nonce. This can be ensured by following these rules:
  ///
  /// 1. Each call to this function must have a UNIQUE session_secrand32 that must
  /// NOT BE REUSED in subsequent calls to this function and must be KEPT
  /// SECRET (even from other signers).
  /// 2. If you already know the seckey, message or aggregate public key
  /// cache, they can be optionally provided to derive the nonce and increase
  /// misuse-resistance. The extra_input32 argument can be used to provide
  /// additional data that does not repeat in normal scenarios, such as the
  /// current time.
  /// 3. Avoid copying (or serializing) the secnonce. This reduces the possibility
  /// that it is used more than once for signing.
  ///
  /// If you don't have access to good randomness for session_secrand32, but you
  /// have access to a non-repeating counter, then see
  /// secp256k1_musig_nonce_gen_counter.
  ///
  /// Remember that nonce reuse will leak the secret key!
  /// Note that using the same seckey for multiple MuSig sessions is fine.
  ///
  /// Returns: 0 if the arguments are invalid and 1 otherwise
  /// Args:         ctx: pointer to a context object (not secp256k1_context_static)
  /// Out:     secnonce: pointer to a structure to store the secret nonce
  /// pubnonce: pointer to a structure to store the public nonce
  /// In/Out:
  /// session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this
  /// call to secp256k1_musig_nonce_gen and must be uniformly
  /// random. If the function call is successful, the
  /// session_secrand32 buffer is invalidated to prevent reuse.
  /// In:
  /// seckey: the 32-byte secret key that will later be used for signing, if
  /// already known (can be NULL)
  /// pubkey: public key of the signer creating the nonce. The secnonce
  /// output of this function cannot be used to sign for any
  /// other public key. While the public key should correspond
  /// to the provided seckey, a mismatch will not cause the
  /// function to return 0.
  /// msg32: the 32-byte message that will later be signed, if already known
  /// (can be NULL)
  /// keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate
  /// (and potentially tweaked) public key if already known
  /// (can be NULL)
  /// extra_input32: an optional 32-byte array that is input to the nonce
  /// derivation function (can be NULL)
  int secp256k1_musig_nonce_gen(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_musig_secnonce> secnonce,
    ffi.Pointer<secp256k1_musig_pubnonce> pubnonce,
    ffi.Pointer<ffi.UnsignedChar> session_secrand32,
    ffi.Pointer<ffi.UnsignedChar> seckey,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<ffi.UnsignedChar> msg32,
    ffi.Pointer<secp256k1_musig_keyagg_cache> keyagg_cache,
    ffi.Pointer<ffi.UnsignedChar> extra_input32,
  ) {
    return _secp256k1_musig_nonce_gen(
      ctx,
      secnonce,
      pubnonce,
      session_secrand32,
      seckey,
      pubkey,
      msg32,
      keyagg_cache,
      extra_input32,
    );
  }

  late final _secp256k1_musig_nonce_genPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_musig_secnonce>,
              ffi.Pointer<secp256k1_musig_pubnonce>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_musig_keyagg_cache>,
              ffi.Pointer<ffi.UnsignedChar>)>>('secp256k1_musig_nonce_gen');
  late final _secp256k1_musig_nonce_gen =
      _secp256k1_musig_nonce_genPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_musig_secnonce>,
              ffi.Pointer<secp256k1_musig_pubnonce>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_musig_keyagg_cache>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Alternative way to generate a nonce and start a signing session
  ///
  /// This function outputs a secret nonce that will be required for signing and a
  /// corresponding public nonce that is intended to be sent to other signers.
  ///
  /// This function differs from `secp256k1_musig_nonce_gen` by accepting a
  /// non-repeating counter value instead of a secret random value. This requires
  /// that a secret key is provided to `secp256k1_musig_nonce_gen_counter`
  /// (through the keypair argument), as opposed to `secp256k1_musig_nonce_gen`
  /// where the seckey argument is optional.
  ///
  /// MuSig differs from regular Schnorr signing in that implementers _must_ take
  /// special care to not reuse a nonce. This can be ensured by following these rules:
  ///
  /// 1. The nonrepeating_cnt argument must be a counter value that never repeats,
  /// i.e., you must never call `secp256k1_musig_nonce_gen_counter` twice with
  /// the same keypair and nonrepeating_cnt value. For example, this implies
  /// that if the same keypair is used with `secp256k1_musig_nonce_gen_counter`
  /// on multiple devices, none of the devices should have the same counter
  /// value as any other device.
  /// 2. If the seckey, message or aggregate public key cache is already available
  /// at this stage, any of these can be optionally provided, in which case
  /// they will be used in the derivation of the nonce and increase
  /// misuse-resistance. The extra_input32 argument can be used to provide
  /// additional data that does not repeat in normal scenarios, such as the
  /// current time.
  /// 3. Avoid copying (or serializing) the secnonce. This reduces the possibility
  /// that it is used more than once for signing.
  ///
  /// Remember that nonce reuse will leak the secret key!
  /// Note that using the same keypair for multiple MuSig sessions is fine.
  ///
  /// Returns: 0 if the arguments are invalid and 1 otherwise
  /// Args:         ctx: pointer to a context object (not secp256k1_context_static)
  /// Out:     secnonce: pointer to a structure to store the secret nonce
  /// pubnonce: pointer to a structure to store the public nonce
  /// In:
  /// nonrepeating_cnt: the value of a counter as explained above. Must be
  /// unique to this call to secp256k1_musig_nonce_gen.
  /// keypair: keypair of the signer creating the nonce. The secnonce
  /// output of this function cannot be used to sign for any
  /// other keypair.
  /// msg32: the 32-byte message that will later be signed, if already known
  /// (can be NULL)
  /// keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate
  /// (and potentially tweaked) public key if already known
  /// (can be NULL)
  /// extra_input32: an optional 32-byte array that is input to the nonce
  /// derivation function (can be NULL)
  int secp256k1_musig_nonce_gen_counter(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_musig_secnonce> secnonce,
    ffi.Pointer<secp256k1_musig_pubnonce> pubnonce,
    int nonrepeating_cnt,
    ffi.Pointer<secp256k1_keypair> keypair,
    ffi.Pointer<ffi.UnsignedChar> msg32,
    ffi.Pointer<secp256k1_musig_keyagg_cache> keyagg_cache,
    ffi.Pointer<ffi.UnsignedChar> extra_input32,
  ) {
    return _secp256k1_musig_nonce_gen_counter(
      ctx,
      secnonce,
      pubnonce,
      nonrepeating_cnt,
      keypair,
      msg32,
      keyagg_cache,
      extra_input32,
    );
  }

  late final _secp256k1_musig_nonce_gen_counterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_musig_secnonce>,
                  ffi.Pointer<secp256k1_musig_pubnonce>,
                  ffi.Uint64,
                  ffi.Pointer<secp256k1_keypair>,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Pointer<secp256k1_musig_keyagg_cache>,
                  ffi.Pointer<ffi.UnsignedChar>)>>(
      'secp256k1_musig_nonce_gen_counter');
  late final _secp256k1_musig_nonce_gen_counter =
      _secp256k1_musig_nonce_gen_counterPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_musig_secnonce>,
              ffi.Pointer<secp256k1_musig_pubnonce>,
              int,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_musig_keyagg_cache>,
              ffi.Pointer<ffi.UnsignedChar>)>();

  /// Aggregates the nonces of all signers into a single nonce
  ///
  /// This can be done by an untrusted party to reduce the communication
  /// between signers. Instead of everyone sending nonces to everyone else, there
  /// can be one party receiving all nonces, aggregating the nonces with this
  /// function and then sending only the aggregate nonce back to the signers.
  ///
  /// If the aggregator does not compute the aggregate nonce correctly, the final
  /// signature will be invalid.
  ///
  /// Returns: 0 if the arguments are invalid, 1 otherwise
  /// Args:           ctx: pointer to a context object
  /// Out:       aggnonce: pointer to an aggregate public nonce object for
  /// musig_nonce_process
  /// In:       pubnonces: array of pointers to public nonces sent by the
  /// signers
  /// n_pubnonces: number of elements in the pubnonces array. Must be
  /// greater than 0.
  int secp256k1_musig_nonce_agg(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_musig_aggnonce> aggnonce,
    ffi.Pointer<ffi.Pointer<secp256k1_musig_pubnonce>> pubnonces,
    int n_pubnonces,
  ) {
    return _secp256k1_musig_nonce_agg(
      ctx,
      aggnonce,
      pubnonces,
      n_pubnonces,
    );
  }

  late final _secp256k1_musig_nonce_aggPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_musig_aggnonce>,
              ffi.Pointer<ffi.Pointer<secp256k1_musig_pubnonce>>,
              ffi.Size)>>('secp256k1_musig_nonce_agg');
  late final _secp256k1_musig_nonce_agg =
      _secp256k1_musig_nonce_aggPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_musig_aggnonce>,
              ffi.Pointer<ffi.Pointer<secp256k1_musig_pubnonce>>,
              int)>();

  /// Takes the aggregate nonce and creates a session that is required for signing
  /// and verification of partial signatures.
  ///
  /// If the adaptor argument is non-NULL, then the output of
  /// musig_partial_sig_agg will be a pre-signature which is not a valid Schnorr
  /// signature. In order to create a valid signature, the pre-signature and the
  /// secret adaptor must be provided to `musig_adapt`.
  ///
  /// Returns: 0 if the arguments are invalid, 1 otherwise
  /// Args:          ctx: pointer to a context object
  /// Out:       session: pointer to a struct to store the session
  /// In:       aggnonce: pointer to an aggregate public nonce object that is the
  /// output of musig_nonce_agg
  /// msg32:  the 32-byte message to sign
  /// keyagg_cache:  pointer to the keyagg_cache that was used to create the
  /// aggregate (and potentially tweaked) pubkey
  /// adaptor:  optional pointer to an adaptor point encoded as a public
  /// key if this signing session is part of an adaptor
  /// signature protocol (can be NULL)
  int secp256k1_musig_nonce_process(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_musig_session> session,
    ffi.Pointer<secp256k1_musig_aggnonce> aggnonce,
    ffi.Pointer<ffi.UnsignedChar> msg32,
    ffi.Pointer<secp256k1_musig_keyagg_cache> keyagg_cache,
    ffi.Pointer<secp256k1_pubkey> adaptor,
  ) {
    return _secp256k1_musig_nonce_process(
      ctx,
      session,
      aggnonce,
      msg32,
      keyagg_cache,
      adaptor,
    );
  }

  late final _secp256k1_musig_nonce_processPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_musig_session>,
              ffi.Pointer<secp256k1_musig_aggnonce>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_musig_keyagg_cache>,
              ffi.Pointer<secp256k1_pubkey>)>>('secp256k1_musig_nonce_process');
  late final _secp256k1_musig_nonce_process =
      _secp256k1_musig_nonce_processPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_musig_session>,
              ffi.Pointer<secp256k1_musig_aggnonce>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_musig_keyagg_cache>,
              ffi.Pointer<secp256k1_pubkey>)>();

  /// Produces a partial signature
  ///
  /// This function overwrites the given secnonce with zeros and will abort if given a
  /// secnonce that is all zeros. This is a best effort attempt to protect against nonce
  /// reuse. However, this is of course easily defeated if the secnonce has been
  /// copied (or serialized). Remember that nonce reuse will leak the secret key!
  ///
  /// For signing to succeed, the secnonce provided to this function must have
  /// been generated for the provided keypair. This means that when signing for a
  /// keypair consisting of a seckey and pubkey, the secnonce must have been
  /// created by calling musig_nonce_gen with that pubkey. Otherwise, the
  /// illegal_callback is called.
  ///
  /// This function does not verify the output partial signature, deviating from
  /// the BIP 327 specification. It is recommended to verify the output partial
  /// signature with `secp256k1_musig_partial_sig_verify` to prevent random or
  /// adversarially provoked computation errors.
  ///
  /// Returns: 0 if the arguments are invalid or the provided secnonce has already
  /// been used for signing, 1 otherwise
  /// Args:         ctx: pointer to a context object
  /// Out:  partial_sig: pointer to struct to store the partial signature
  /// In/Out:  secnonce: pointer to the secnonce struct created in
  /// musig_nonce_gen that has been never used in a
  /// partial_sign call before and has been created for the
  /// keypair
  /// In:       keypair: pointer to keypair to sign the message with
  /// keyagg_cache: pointer to the keyagg_cache that was output when the
  /// aggregate public key for this session
  /// session: pointer to the session that was created with
  /// musig_nonce_process
  int secp256k1_musig_partial_sign(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_musig_partial_sig> partial_sig,
    ffi.Pointer<secp256k1_musig_secnonce> secnonce,
    ffi.Pointer<secp256k1_keypair> keypair,
    ffi.Pointer<secp256k1_musig_keyagg_cache> keyagg_cache,
    ffi.Pointer<secp256k1_musig_session> session,
  ) {
    return _secp256k1_musig_partial_sign(
      ctx,
      partial_sig,
      secnonce,
      keypair,
      keyagg_cache,
      session,
    );
  }

  late final _secp256k1_musig_partial_signPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_musig_partial_sig>,
                  ffi.Pointer<secp256k1_musig_secnonce>,
                  ffi.Pointer<secp256k1_keypair>,
                  ffi.Pointer<secp256k1_musig_keyagg_cache>,
                  ffi.Pointer<secp256k1_musig_session>)>>(
      'secp256k1_musig_partial_sign');
  late final _secp256k1_musig_partial_sign =
      _secp256k1_musig_partial_signPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_musig_partial_sig>,
              ffi.Pointer<secp256k1_musig_secnonce>,
              ffi.Pointer<secp256k1_keypair>,
              ffi.Pointer<secp256k1_musig_keyagg_cache>,
              ffi.Pointer<secp256k1_musig_session>)>();

  /// Verifies an individual signer's partial signature
  ///
  /// The signature is verified for a specific signing session. In order to avoid
  /// accidentally verifying a signature from a different or non-existing signing
  /// session, you must ensure the following:
  /// 1. The `keyagg_cache` argument is identical to the one used to create the
  /// `session` with `musig_nonce_process`.
  /// 2. The `pubkey` argument must be identical to the one sent by the signer
  /// before aggregating it with `musig_pubkey_agg` to create the
  /// `keyagg_cache`.
  /// 3. The `pubnonce` argument must be identical to the one sent by the signer
  /// before aggregating it with `musig_nonce_agg` and using the result to
  /// create the `session` with `musig_nonce_process`.
  ///
  /// This function is essential when using protocols with adaptor signatures.
  /// However, it is not essential for regular MuSig sessions, in the sense that if any
  /// partial signature does not verify, the full signature will not verify either, so the
  /// problem will be caught. But this function allows determining the specific party
  /// who produced an invalid signature.
  ///
  /// Returns: 0 if the arguments are invalid or the partial signature does not
  /// verify, 1 otherwise
  /// Args         ctx: pointer to a context object
  /// In:  partial_sig: pointer to partial signature to verify, sent by
  /// the signer associated with `pubnonce` and `pubkey`
  /// pubnonce: public nonce of the signer in the signing session
  /// pubkey: public key of the signer in the signing session
  /// keyagg_cache: pointer to the keyagg_cache that was output when the
  /// aggregate public key for this signing session
  /// session: pointer to the session that was created with
  /// `musig_nonce_process`
  int secp256k1_musig_partial_sig_verify(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<secp256k1_musig_partial_sig> partial_sig,
    ffi.Pointer<secp256k1_musig_pubnonce> pubnonce,
    ffi.Pointer<secp256k1_pubkey> pubkey,
    ffi.Pointer<secp256k1_musig_keyagg_cache> keyagg_cache,
    ffi.Pointer<secp256k1_musig_session> session,
  ) {
    return _secp256k1_musig_partial_sig_verify(
      ctx,
      partial_sig,
      pubnonce,
      pubkey,
      keyagg_cache,
      session,
    );
  }

  late final _secp256k1_musig_partial_sig_verifyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<secp256k1_musig_partial_sig>,
                  ffi.Pointer<secp256k1_musig_pubnonce>,
                  ffi.Pointer<secp256k1_pubkey>,
                  ffi.Pointer<secp256k1_musig_keyagg_cache>,
                  ffi.Pointer<secp256k1_musig_session>)>>(
      'secp256k1_musig_partial_sig_verify');
  late final _secp256k1_musig_partial_sig_verify =
      _secp256k1_musig_partial_sig_verifyPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<secp256k1_musig_partial_sig>,
              ffi.Pointer<secp256k1_musig_pubnonce>,
              ffi.Pointer<secp256k1_pubkey>,
              ffi.Pointer<secp256k1_musig_keyagg_cache>,
              ffi.Pointer<secp256k1_musig_session>)>();

  /// Aggregates partial signatures
  ///
  /// Returns: 0 if the arguments are invalid, 1 otherwise (which does NOT mean
  /// the resulting signature verifies).
  /// Args:         ctx: pointer to a context object
  /// Out:        sig64: complete (but possibly invalid) Schnorr signature
  /// In:       session: pointer to the session that was created with
  /// musig_nonce_process
  /// partial_sigs: array of pointers to partial signatures to aggregate
  /// n_sigs: number of elements in the partial_sigs array. Must be
  /// greater than 0.
  int secp256k1_musig_partial_sig_agg(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> sig64,
    ffi.Pointer<secp256k1_musig_session> session,
    ffi.Pointer<ffi.Pointer<secp256k1_musig_partial_sig>> partial_sigs,
    int n_sigs,
  ) {
    return _secp256k1_musig_partial_sig_agg(
      ctx,
      sig64,
      session,
      partial_sigs,
      n_sigs,
    );
  }

  late final _secp256k1_musig_partial_sig_aggPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_musig_session>,
              ffi.Pointer<ffi.Pointer<secp256k1_musig_partial_sig>>,
              ffi.Size)>>('secp256k1_musig_partial_sig_agg');
  late final _secp256k1_musig_partial_sig_agg =
      _secp256k1_musig_partial_sig_aggPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<secp256k1_musig_session>,
              ffi.Pointer<ffi.Pointer<secp256k1_musig_partial_sig>>,
              int)>();

  /// Extracts the nonce_parity bit from a session
  ///
  /// This is used for adaptor signatures.
  ///
  /// Returns: 0 if the arguments are invalid, 1 otherwise
  /// Args:         ctx: pointer to a context object
  /// Out: nonce_parity: pointer to an integer that indicates the parity
  /// of the aggregate public nonce. Used for adaptor
  /// signatures.
  /// In:       session: pointer to the session that was created with
  /// musig_nonce_process
  int secp256k1_musig_nonce_parity(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.Int> nonce_parity,
    ffi.Pointer<secp256k1_musig_session> session,
  ) {
    return _secp256k1_musig_nonce_parity(
      ctx,
      nonce_parity,
      session,
    );
  }

  late final _secp256k1_musig_nonce_parityPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<secp256k1_context>,
                  ffi.Pointer<ffi.Int>, ffi.Pointer<secp256k1_musig_session>)>>(
      'secp256k1_musig_nonce_parity');
  late final _secp256k1_musig_nonce_parity =
      _secp256k1_musig_nonce_parityPtr.asFunction<
          int Function(ffi.Pointer<secp256k1_context>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<secp256k1_musig_session>)>();

  /// Creates a signature from a pre-signature and an adaptor.
  ///
  /// If the sec_adaptor32 argument is incorrect, the output signature will be
  /// invalid. This function does not verify the signature.
  ///
  /// Returns: 0 if the arguments are invalid, or pre_sig64 or sec_adaptor32 contain
  /// invalid (overflowing) values. 1 otherwise (which does NOT mean the
  /// signature or the adaptor are valid!)
  /// Args:         ctx: pointer to a context object
  /// Out:        sig64: 64-byte signature. This pointer may point to the same
  /// memory area as `pre_sig`.
  /// In:     pre_sig64: 64-byte pre-signature
  /// sec_adaptor32: 32-byte secret adaptor to add to the pre-signature
  /// nonce_parity: the output of `musig_nonce_parity` called with the
  /// session used for producing the pre-signature
  int secp256k1_musig_adapt(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> sig64,
    ffi.Pointer<ffi.UnsignedChar> pre_sig64,
    ffi.Pointer<ffi.UnsignedChar> sec_adaptor32,
    int nonce_parity,
  ) {
    return _secp256k1_musig_adapt(
      ctx,
      sig64,
      pre_sig64,
      sec_adaptor32,
      nonce_parity,
    );
  }

  late final _secp256k1_musig_adaptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int)>>('secp256k1_musig_adapt');
  late final _secp256k1_musig_adapt = _secp256k1_musig_adaptPtr.asFunction<
      int Function(
          ffi.Pointer<secp256k1_context>,
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<ffi.UnsignedChar>,
          int)>();

  /// Extracts a secret adaptor from a MuSig pre-signature and corresponding
  /// signature
  ///
  /// This function will not fail unless given grossly invalid data; if it is
  /// merely given signatures that do not verify, the returned value will be
  /// nonsense. It is therefore important that all data be verified at earlier
  /// steps of any protocol that uses this function. In particular, this includes
  /// verifying all partial signatures that were aggregated into pre_sig64.
  ///
  /// Returns: 0 if the arguments are NULL, or sig64 or pre_sig64 contain
  /// grossly invalid (overflowing) values. 1 otherwise (which does NOT
  /// mean the signatures or the adaptor are valid!)
  /// Args:         ctx: pointer to a context object
  /// Out:sec_adaptor32: 32-byte secret adaptor
  /// In:         sig64: complete, valid 64-byte signature
  /// pre_sig64: the pre-signature corresponding to sig64, i.e., the
  /// aggregate of partial signatures without the secret
  /// adaptor
  /// nonce_parity: the output of `musig_nonce_parity` called with the
  /// session used for producing sig64
  int secp256k1_musig_extract_adaptor(
    ffi.Pointer<secp256k1_context> ctx,
    ffi.Pointer<ffi.UnsignedChar> sec_adaptor32,
    ffi.Pointer<ffi.UnsignedChar> sig64,
    ffi.Pointer<ffi.UnsignedChar> pre_sig64,
    int nonce_parity,
  ) {
    return _secp256k1_musig_extract_adaptor(
      ctx,
      sec_adaptor32,
      sig64,
      pre_sig64,
      nonce_parity,
    );
  }

  late final _secp256k1_musig_extract_adaptorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int)>>('secp256k1_musig_extract_adaptor');
  late final _secp256k1_musig_extract_adaptor =
      _secp256k1_musig_extract_adaptorPtr.asFunction<
          int Function(
              ffi.Pointer<secp256k1_context>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedChar>,
              int)>();
}

typedef ptrdiff_t = ffi.Long;
typedef Dartptrdiff_t = int;

final class max_align_t extends ffi.Opaque {}

final class secp256k1_context_struct extends ffi.Opaque {}

/// Opaque data structure that holds context information
///
/// The primary purpose of context objects is to store randomization data for
/// enhanced protection against side-channel leakage. This protection is only
/// effective if the context is randomized after its creation. See
/// secp256k1_context_create for creation of contexts and
/// secp256k1_context_randomize for randomization.
///
/// A secondary purpose of context objects is to store pointers to callback
/// functions that the library will call when certain error states arise. See
/// secp256k1_context_set_error_callback as well as
/// secp256k1_context_set_illegal_callback for details. Future library versions
/// may use context objects for additional purposes.
///
/// A constructed context can safely be used from multiple threads
/// simultaneously, but API calls that take a non-const pointer to a context
/// need exclusive access to it. In particular this is the case for
/// secp256k1_context_destroy, secp256k1_context_preallocated_destroy,
/// and secp256k1_context_randomize.
///
/// Regarding randomization, either do it once at creation time (in which case
/// you do not need any locking for the other calls), or use a read-write lock.
typedef secp256k1_context = secp256k1_context_struct;

/// Opaque data structure that holds a parsed and valid public key.
///
/// The exact representation of data inside is implementation defined and not
/// guaranteed to be portable between different platforms or versions. It is
/// however guaranteed to be 64 bytes in size, and can be safely copied/moved.
/// If you need to convert to a format suitable for storage or transmission,
/// use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse. To
/// compare keys, use secp256k1_ec_pubkey_cmp.
final class secp256k1_pubkey extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// Opaque data structure that holds a parsed ECDSA signature.
///
/// The exact representation of data inside is implementation defined and not
/// guaranteed to be portable between different platforms or versions. It is
/// however guaranteed to be 64 bytes in size, and can be safely copied/moved.
/// If you need to convert to a format suitable for storage, transmission, or
/// comparison, use the secp256k1_ecdsa_signature_serialize_* and
/// secp256k1_ecdsa_signature_parse_* functions.
final class secp256k1_ecdsa_signature extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.UnsignedChar> data;
}

typedef secp256k1_nonce_functionFunction = ffi.Int Function(
    ffi.Pointer<ffi.UnsignedChar> nonce32,
    ffi.Pointer<ffi.UnsignedChar> msg32,
    ffi.Pointer<ffi.UnsignedChar> key32,
    ffi.Pointer<ffi.UnsignedChar> algo16,
    ffi.Pointer<ffi.Void> data,
    ffi.UnsignedInt attempt);
typedef Dartsecp256k1_nonce_functionFunction = int Function(
    ffi.Pointer<ffi.UnsignedChar> nonce32,
    ffi.Pointer<ffi.UnsignedChar> msg32,
    ffi.Pointer<ffi.UnsignedChar> key32,
    ffi.Pointer<ffi.UnsignedChar> algo16,
    ffi.Pointer<ffi.Void> data,
    int attempt);

/// A pointer to a function to deterministically generate a nonce.
///
/// Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.
/// Out:     nonce32:   pointer to a 32-byte array to be filled by the function.
/// In:      msg32:     the 32-byte message hash being verified (will not be NULL)
/// key32:     pointer to a 32-byte secret key (will not be NULL)
/// algo16:    pointer to a 16-byte array describing the signature
/// algorithm (will be NULL for ECDSA for compatibility).
/// data:      Arbitrary data pointer that is passed through.
/// attempt:   how many iterations we have tried to find a nonce.
/// This will almost always be 0, but different attempt values
/// are required to result in a different nonce.
///
/// Except for test cases, this function should compute some cryptographic hash of
/// the message, the algorithm, the key and the attempt.
typedef secp256k1_nonce_function
    = ffi.Pointer<ffi.NativeFunction<secp256k1_nonce_functionFunction>>;

/// Opaque data structure that holds a parsed ECDSA signature,
/// supporting pubkey recovery.
///
/// The exact representation of data inside is implementation defined and not
/// guaranteed to be portable between different platforms or versions. It is
/// however guaranteed to be 65 bytes in size, and can be safely copied/moved.
/// If you need to convert to a format suitable for storage or transmission, use
/// the secp256k1_ecdsa_signature_serialize_* and
/// secp256k1_ecdsa_signature_parse_* functions.
///
/// Furthermore, it is guaranteed that identical signatures (including their
/// recoverability) will have identical representation, so they can be
/// memcmp'ed.
final class secp256k1_ecdsa_recoverable_signature extends ffi.Struct {
  @ffi.Array.multi([65])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// Opaque data structure that holds a parsed and valid "x-only" public key.
/// An x-only pubkey encodes a point whose Y coordinate is even. It is
/// serialized using only its X coordinate (32 bytes). See BIP-340 for more
/// information about x-only pubkeys.
///
/// The exact representation of data inside is implementation defined and not
/// guaranteed to be portable between different platforms or versions. It is
/// however guaranteed to be 64 bytes in size, and can be safely copied/moved.
/// If you need to convert to a format suitable for storage, transmission, use
/// use secp256k1_xonly_pubkey_serialize and secp256k1_xonly_pubkey_parse. To
/// compare keys, use secp256k1_xonly_pubkey_cmp.
final class secp256k1_xonly_pubkey extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// Opaque data structure that holds a keypair consisting of a secret and a
/// public key.
///
/// The exact representation of data inside is implementation defined and not
/// guaranteed to be portable between different platforms or versions. It is
/// however guaranteed to be 96 bytes in size, and can be safely copied/moved.
final class secp256k1_keypair extends ffi.Struct {
  @ffi.Array.multi([96])
  external ffi.Array<ffi.UnsignedChar> data;
}

typedef secp256k1_nonce_function_hardenedFunction = ffi.Int Function(
    ffi.Pointer<ffi.UnsignedChar> nonce32,
    ffi.Pointer<ffi.UnsignedChar> msg,
    ffi.Size msglen,
    ffi.Pointer<ffi.UnsignedChar> key32,
    ffi.Pointer<ffi.UnsignedChar> xonly_pk32,
    ffi.Pointer<ffi.UnsignedChar> algo,
    ffi.Size algolen,
    ffi.Pointer<ffi.Void> data);
typedef Dartsecp256k1_nonce_function_hardenedFunction = int Function(
    ffi.Pointer<ffi.UnsignedChar> nonce32,
    ffi.Pointer<ffi.UnsignedChar> msg,
    int msglen,
    ffi.Pointer<ffi.UnsignedChar> key32,
    ffi.Pointer<ffi.UnsignedChar> xonly_pk32,
    ffi.Pointer<ffi.UnsignedChar> algo,
    int algolen,
    ffi.Pointer<ffi.Void> data);

/// A pointer to a function to deterministically generate a nonce.
///
/// Same as secp256k1_nonce function with the exception of accepting an
/// additional pubkey argument and not requiring an attempt argument. The pubkey
/// argument can protect signature schemes with key-prefixed challenge hash
/// inputs against reusing the nonce when signing with the wrong precomputed
/// pubkey.
///
/// Returns: 1 if a nonce was successfully generated. 0 will cause signing to
/// return an error.
/// Out:  nonce32: pointer to a 32-byte array to be filled by the function
/// In:       msg: the message being verified. Is NULL if and only if msglen
/// is 0.
/// msglen: the length of the message
/// key32: pointer to a 32-byte secret key (will not be NULL)
/// xonly_pk32: the 32-byte serialized xonly pubkey corresponding to key32
/// (will not be NULL)
/// algo: pointer to an array describing the signature
/// algorithm (will not be NULL)
/// algolen: the length of the algo array
/// data: arbitrary data pointer that is passed through
///
/// Except for test cases, this function should compute some cryptographic hash of
/// the message, the key, the pubkey, the algorithm description, and data.
typedef secp256k1_nonce_function_hardened = ffi
    .Pointer<ffi.NativeFunction<secp256k1_nonce_function_hardenedFunction>>;

/// Data structure that contains additional arguments for schnorrsig_sign_custom.
///
/// A schnorrsig_extraparams structure object can be initialized correctly by
/// setting it to SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT.
///
/// Members:
/// magic: set to SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC at initialization
/// and has no other function than making sure the object is
/// initialized.
/// noncefp: pointer to a nonce generation function. If NULL,
/// secp256k1_nonce_function_bip340 is used
/// ndata: pointer to arbitrary data used by the nonce generation function
/// (can be NULL). If it is non-NULL and
/// secp256k1_nonce_function_bip340 is used, then ndata must be a
/// pointer to 32-byte auxiliary randomness as per BIP-340.
final class secp256k1_schnorrsig_extraparams extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedChar> magic;

  external secp256k1_nonce_function_hardened noncefp;

  external ffi.Pointer<ffi.Void> ndata;
}

typedef secp256k1_ecdh_hash_functionFunction = ffi.Int Function(
    ffi.Pointer<ffi.UnsignedChar> output,
    ffi.Pointer<ffi.UnsignedChar> x32,
    ffi.Pointer<ffi.UnsignedChar> y32,
    ffi.Pointer<ffi.Void> data);
typedef Dartsecp256k1_ecdh_hash_functionFunction = int Function(
    ffi.Pointer<ffi.UnsignedChar> output,
    ffi.Pointer<ffi.UnsignedChar> x32,
    ffi.Pointer<ffi.UnsignedChar> y32,
    ffi.Pointer<ffi.Void> data);

/// A pointer to a function that hashes an EC point to obtain an ECDH secret
///
/// Returns: 1 if the point was successfully hashed.
/// 0 will cause secp256k1_ecdh to fail and return 0.
/// Other return values are not allowed, and the behaviour of
/// secp256k1_ecdh is undefined for other return values.
/// Out:     output:     pointer to an array to be filled by the function
/// In:      x32:        pointer to a 32-byte x coordinate
/// y32:        pointer to a 32-byte y coordinate
/// data:       arbitrary data pointer that is passed through
typedef secp256k1_ecdh_hash_function
    = ffi.Pointer<ffi.NativeFunction<secp256k1_ecdh_hash_functionFunction>>;
typedef int_least8_t = ffi.SignedChar;
typedef int_least16_t = ffi.Short;
typedef int_least32_t = ffi.Int;
typedef int_least64_t = ffi.Long;
typedef uint_least8_t = ffi.UnsignedChar;
typedef uint_least16_t = ffi.UnsignedShort;
typedef uint_least32_t = ffi.UnsignedInt;
typedef uint_least64_t = ffi.UnsignedLong;
typedef int_fast8_t = ffi.SignedChar;
typedef Dartint_fast8_t = int;
typedef int_fast16_t = ffi.Long;
typedef Dartint_fast16_t = int;
typedef int_fast32_t = ffi.Long;
typedef Dartint_fast32_t = int;
typedef int_fast64_t = ffi.Long;
typedef Dartint_fast64_t = int;
typedef uint_fast8_t = ffi.UnsignedChar;
typedef Dartuint_fast8_t = int;
typedef uint_fast16_t = ffi.UnsignedLong;
typedef Dartuint_fast16_t = int;
typedef uint_fast32_t = ffi.UnsignedLong;
typedef Dartuint_fast32_t = int;
typedef uint_fast64_t = ffi.UnsignedLong;
typedef Dartuint_fast64_t = int;
typedef intmax_t = ffi.Long;
typedef uintmax_t = ffi.UnsignedLong;

/// Opaque data structure that caches information about public key aggregation.
///
/// Guaranteed to be 197 bytes in size. No serialization and parsing functions
/// (yet).
final class secp256k1_musig_keyagg_cache extends ffi.Struct {
  @ffi.Array.multi([197])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// Opaque data structure that holds a signer's _secret_ nonce.
///
/// Guaranteed to be 132 bytes in size.
///
/// WARNING: This structure MUST NOT be copied or read or written to directly. A
/// signer who is online throughout the whole process and can keep this
/// structure in memory can use the provided API functions for a safe standard
/// workflow.
///
/// Copying this data structure can result in nonce reuse which will leak the
/// secret signing key.
final class secp256k1_musig_secnonce extends ffi.Struct {
  @ffi.Array.multi([132])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// Opaque data structure that holds a signer's public nonce.
///
/// Guaranteed to be 132 bytes in size. Serialized and parsed with
/// `musig_pubnonce_serialize` and `musig_pubnonce_parse`.
final class secp256k1_musig_pubnonce extends ffi.Struct {
  @ffi.Array.multi([132])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// Opaque data structure that holds an aggregate public nonce.
///
/// Guaranteed to be 132 bytes in size. Serialized and parsed with
/// `musig_aggnonce_serialize` and `musig_aggnonce_parse`.
final class secp256k1_musig_aggnonce extends ffi.Struct {
  @ffi.Array.multi([132])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// Opaque data structure that holds a MuSig session.
///
/// This structure is not required to be kept secret for the signing protocol to
/// be secure. Guaranteed to be 133 bytes in size. No serialization and parsing
/// functions (yet).
final class secp256k1_musig_session extends ffi.Struct {
  @ffi.Array.multi([133])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// Opaque data structure that holds a partial MuSig signature.
///
/// Guaranteed to be 36 bytes in size. Serialized and parsed with
/// `musig_partial_sig_serialize` and `musig_partial_sig_parse`.
final class secp256k1_musig_partial_sig extends ffi.Struct {
  @ffi.Array.multi([36])
  external ffi.Array<ffi.UnsignedChar> data;
}

const int NULL = 0;

const int SECP256K1_FLAGS_TYPE_MASK = 255;

const int SECP256K1_FLAGS_TYPE_CONTEXT = 1;

const int SECP256K1_FLAGS_TYPE_COMPRESSION = 2;

const int SECP256K1_FLAGS_BIT_CONTEXT_VERIFY = 256;

const int SECP256K1_FLAGS_BIT_CONTEXT_SIGN = 512;

const int SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY = 1024;

const int SECP256K1_FLAGS_BIT_COMPRESSION = 256;

const int SECP256K1_CONTEXT_NONE = 1;

const int SECP256K1_CONTEXT_VERIFY = 257;

const int SECP256K1_CONTEXT_SIGN = 513;

const int SECP256K1_CONTEXT_DECLASSIFY = 1025;

const int SECP256K1_EC_COMPRESSED = 258;

const int SECP256K1_EC_UNCOMPRESSED = 2;

const int SECP256K1_TAG_PUBKEY_EVEN = 2;

const int SECP256K1_TAG_PUBKEY_ODD = 3;

const int SECP256K1_TAG_PUBKEY_UNCOMPRESSED = 4;

const int SECP256K1_TAG_PUBKEY_HYBRID_EVEN = 6;

const int SECP256K1_TAG_PUBKEY_HYBRID_ODD = 7;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -9223372036854775808;

const int INT_FAST32_MIN = -9223372036854775808;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 9223372036854775807;

const int INT_FAST32_MAX = 9223372036854775807;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = -1;

const int UINT_FAST32_MAX = -1;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int SIZE_MAX = -1;

const int WCHAR_MIN = -2147483648;

const int WCHAR_MAX = 2147483647;

const int WINT_MIN = 0;

const int WINT_MAX = 4294967295;
